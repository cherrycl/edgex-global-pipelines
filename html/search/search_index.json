{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EdgeX Global Pipelines Summary This repository contains useful Jenkins global library functions used within the EdgeX Jenkins ecosystem. It provides pre-built pipelines to build and publish Go/C++ based source code in a consistent manner. There are also a lot of utility functions that allow for things like automated vulnerability scanning via Snyk, code coverage tracking via CodeCov.io and many other things. Below you will find some useful links as well as links to all of our documented pipelines. Please note: Documentation is still under heavy development. Useful Links Source Code EdgeX Jenkins Server Jenkins Shared Libraries Jenkins Shared Libraries edgeXBuildCApp edgeXBuildDocker edgeXBuildGoApp edgeXBuildGoParallel","title":"EdgeX Global Pipelines"},{"location":"#edgex-global-pipelines","text":"","title":"EdgeX Global Pipelines"},{"location":"#summary","text":"This repository contains useful Jenkins global library functions used within the EdgeX Jenkins ecosystem. It provides pre-built pipelines to build and publish Go/C++ based source code in a consistent manner. There are also a lot of utility functions that allow for things like automated vulnerability scanning via Snyk, code coverage tracking via CodeCov.io and many other things. Below you will find some useful links as well as links to all of our documented pipelines. Please note: Documentation is still under heavy development.","title":"Summary"},{"location":"#useful-links","text":"Source Code EdgeX Jenkins Server Jenkins Shared Libraries","title":"Useful Links"},{"location":"#jenkins-shared-libraries","text":"edgeXBuildCApp edgeXBuildDocker edgeXBuildGoApp edgeXBuildGoParallel","title":"Jenkins Shared Libraries"},{"location":"libraries/edgeXBuildCApp/","text":"edgeXBuildCApp Shared Library to build C projects Parameters project - Specify your project name dockerBuildFilePath - Specify your Docker Build file Path dockerFilePath - Specify your Dockerfile path pushImage - Set this false if you dont want to push the image to DockerHub, by default true Usage Basic example edgeXBuildCApp ( project: 'device-bacnet-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.9-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.9' ) Complex example edgeXBuildCApp ( project: 'device-sdk-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.11-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.11' , pushImage: false )","title":"edgeXBuildCApp"},{"location":"libraries/edgeXBuildCApp/#edgexbuildcapp","text":"Shared Library to build C projects","title":"edgeXBuildCApp"},{"location":"libraries/edgeXBuildCApp/#parameters","text":"project - Specify your project name dockerBuildFilePath - Specify your Docker Build file Path dockerFilePath - Specify your Dockerfile path pushImage - Set this false if you dont want to push the image to DockerHub, by default true","title":"Parameters"},{"location":"libraries/edgeXBuildCApp/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildCApp/#basic-example","text":"edgeXBuildCApp ( project: 'device-bacnet-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.9-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.9' )","title":"Basic example"},{"location":"libraries/edgeXBuildCApp/#complex-example","text":"edgeXBuildCApp ( project: 'device-sdk-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.11-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.11' , pushImage: false )","title":"Complex example"},{"location":"libraries/edgeXBuildDocker/","text":"edgeXBuildDocker Shared Library to build docker images Parameters project - Specify your project name dockerImageName - Specify your Docker Image name semver - Set this true for Semantic versioning dockerNexusRepo - Specify Docker Nexus repository Usage Basic example edgeXBuildDocker ( project: 'docker-edgex-consul' , dockerImageName: 'docker-edgex-consul' , semver: true ) Complex example edgeXBuildDocker ( project: 'edgex-taf-common' , mavenSettings: 'taf-settings' , dockerNexusRepo: 'snapshots' , semver: true )","title":"edgeXBuildDocker"},{"location":"libraries/edgeXBuildDocker/#edgexbuilddocker","text":"Shared Library to build docker images","title":"edgeXBuildDocker"},{"location":"libraries/edgeXBuildDocker/#parameters","text":"project - Specify your project name dockerImageName - Specify your Docker Image name semver - Set this true for Semantic versioning dockerNexusRepo - Specify Docker Nexus repository","title":"Parameters"},{"location":"libraries/edgeXBuildDocker/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildDocker/#basic-example","text":"edgeXBuildDocker ( project: 'docker-edgex-consul' , dockerImageName: 'docker-edgex-consul' , semver: true )","title":"Basic example"},{"location":"libraries/edgeXBuildDocker/#complex-example","text":"edgeXBuildDocker ( project: 'edgex-taf-common' , mavenSettings: 'taf-settings' , dockerNexusRepo: 'snapshots' , semver: true )","title":"Complex example"},{"location":"libraries/edgeXBuildGoApp/","text":"edgeXBuildGoApp Shared Library to build Go projects Parameters project - Specify your project name goVersion - Go version Usage Basic example edgeXBuildGoApp ( project: 'device-random-go' , goVersion: '1.15' ) Complex example edgeXBuildGoApp ( project: 'app-functions-sdk-go' , semver: true , goVersion: '1.15' , testScript: 'make test' , buildImage: false , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v2' ] )","title":"edgeXBuildGoApp"},{"location":"libraries/edgeXBuildGoApp/#edgexbuildgoapp","text":"Shared Library to build Go projects","title":"edgeXBuildGoApp"},{"location":"libraries/edgeXBuildGoApp/#parameters","text":"project - Specify your project name goVersion - Go version","title":"Parameters"},{"location":"libraries/edgeXBuildGoApp/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildGoApp/#basic-example","text":"edgeXBuildGoApp ( project: 'device-random-go' , goVersion: '1.15' )","title":"Basic example"},{"location":"libraries/edgeXBuildGoApp/#complex-example","text":"edgeXBuildGoApp ( project: 'app-functions-sdk-go' , semver: true , goVersion: '1.15' , testScript: 'make test' , buildImage: false , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v2' ] )","title":"Complex example"},{"location":"libraries/edgeXBuildGoParallel/","text":"edgeXBuildGoParallel Shared Library to build Go projects and Docker images in parallel. Utilizes docker-compose --parallel to build Docker images found in the workspace. Currently only used for the edgex-go mono-repo. Parameters project - Required Specify your project name dockerFileGlobPath - Required Pattern for finding Dockerfiles to build. Note docker images will be named with the same name as the directory which the Dockerfile was found in with a docker- prefix and -go suffix. Example: docker-<folder>-go more coming soon... Usage Basic example edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , ) Complex example edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , testScript: 'make test' , buildScript: 'make build' , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], buildSnap: true )","title":"edgeXBuildGoParallel"},{"location":"libraries/edgeXBuildGoParallel/#edgexbuildgoparallel","text":"Shared Library to build Go projects and Docker images in parallel. Utilizes docker-compose --parallel to build Docker images found in the workspace. Currently only used for the edgex-go mono-repo.","title":"edgeXBuildGoParallel"},{"location":"libraries/edgeXBuildGoParallel/#parameters","text":"project - Required Specify your project name dockerFileGlobPath - Required Pattern for finding Dockerfiles to build. Note docker images will be named with the same name as the directory which the Dockerfile was found in with a docker- prefix and -go suffix. Example: docker-<folder>-go more coming soon...","title":"Parameters"},{"location":"libraries/edgeXBuildGoParallel/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildGoParallel/#basic-example","text":"edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , )","title":"Basic example"},{"location":"libraries/edgeXBuildGoParallel/#complex-example","text":"edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , testScript: 'make test' , buildScript: 'make build' , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], buildSnap: true )","title":"Complex example"},{"location":"tutorials/","text":"Tutorials More coming soon! Manual Version Bump Pull Request Sandbox Testing","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"More coming soon! Manual Version Bump Pull Request Sandbox Testing","title":"Tutorials"},{"location":"tutorials/docker-build-strategy/","text":"Docker Build Strategy Docker is a great tool for the CI/CD ecosystem. As the EdgeX DevOps community, we made the decision early when designing the EdgeX Jenkins pipelines to make Docker the center of our build strategy. The advantage of using Docker as the build context is that it allows for creating reproducible builds from Jenkins to our local build environment. Thus creating a portable build environment and minimizing build errors between environments. The EdgeX Jenkins pipelines use Docker images as the context for any build. This Docker image is generated from the Dockerfile.build found at the root of every EdgeX repository. Any dependencies or packages required for testing or compilation needs to be added to the Dockerfile.build file. Local Testing If we want to test how the build will run on Jenkins we can follow these steps locally. Example First we build the \"build image\" edgex-ci-build-image cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build Now we run the build image with some make targets and bind mount our current directory to a folder called /ws (workspace) docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Or to put it into a convenient one-liner: cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build . && docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Sending build context to Docker daemon 127kB Step 1/8 : ARG BASE=golang:1.15-alpine Step 2/8 : FROM ${BASE} ---> 1a87ceb1ace5 Step 3/8 : LABEL license='SPDX-License-Identifier: Apache-2.0' copyright='Copyright (c) 2019: Intel' ---> Using cache ---> 9f1aa172c1d7 Step 4/8 : RUN sed -e 's/dl-cdn[.]alpinelinux.org/nl.alpinelinux.org/g' -i~ /etc/apk/repositories ---> Using cache ---> fec4da09e9ec Step 5/8 : RUN apk add --no-cache make git gcc libc-dev libsodium-dev zeromq-dev bash ... Successfully built ce2be0b9fe31 Successfully tagged edgex-ci-build-image:latest CGO_ENABLED=1 go test -coverprofile=coverage.out ./... ? github.com/edgexfoundry/app-service-configurable [no test files] CGO_ENABLED=1 go build -ldflags \"-X github.com/edgexfoundry/app-functions-sdk-go/internal.SDKVersion=v1.2.1-dev.35 -X github.com/edgexfoundry/app-functions-sdk-go/internal.ApplicationVersion=0.0.0\" app-service-configurable Tooling Caveats Docker build images are Alpine based to save on disk space and bandwith and with that comes potential tooling incompatiblities. For example a number of pre-installed base packages on Alpine are the BusyBox versions of the tools. BusyBox versions can sometimes have different arguments than their GNU counterparts. For instance the tar command: BusyBox (Alpine) $ tar --help BusyBox v1.31.1 () multi-call binary. Usage: tar c | x | t [ -ZzJjahmvokO ] [ -f TARFILE ] [ -C DIR ] [ -T FILE ] [ -X FILE ] [ --exclude PATTERN ] ... [ FILE ] ... GNU (Other linux distros) $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. This can lead to unexpected issues if say, for instance, you are depending on a specific flag provided by the tool. One option to fix this is to just use the BusyBox flags, however this may break when not running inside the Docker build image. Another option is to find the alternative package and install that version. For example, Alpine provides the GNU alternative tar binary under the tar Alpine package: $ apk add --update tar $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. The Jenkins Way The above example is similar to how Jenkins runs the build with a few distinctions. First, the make test and make build commands are broken up into two stages. This is an important distinction because it allows for a more granular pipeline allowing for better error handling. The other distinction is that Jenkins takes advantage of a caching base layer image that is passed in at build time. Take a look at the Dockerfile.build. You will notice the BASE docker ARG at the top of the file. ARG BASE = golang:1.15-alpine FROM ${BASE} ... This allows Jenkins to override the base image during the build with an image from Nexus helping to alleviate issues with DockerHub pull limits as well as random Docker pull failures. On Jenkins this happens in the Prep stage: docker build -t ci-base-image-x86_64 \\ -f Dockerfile.build \\ --build-arg BASE = nexus3.edgexfoundry.org:10003/edgex-devops/edgex-golang-base:1.15-alpine \\ . The DevOps WG team manages these Golang base images and the Dockerfile for the latest Golang image used can be found here: https://github.com/edgexfoundry/ci-build-images/tree/golang-1.15 . This cache image contains most of the dependencies used in the majority of the pipelines allowing us to cache dependencies at the base image level and increasing builds speeds. After the base image is built the test and build stages run in a similar manner to the local testing scenario: docker run -t -u 0:0 \\ -w /w/workspace/app-service-configurable/60 \\ -v /w/workspace/app-service-configurable/60:/w/workspace/app-service-configurable/60:rw,z \\ -v /w/workspace/app-service-configurable/60@tmp:/w/workspace/app-service-configurable/60@tmp:rw,z \\ ci-base-image-x86_64 ... make test Next steps More information can be found by reading the documentation or source code of these pipelines: edgeXBuildGoApp source edgeXBuildGoParallel source","title":"Docker Build Strategy"},{"location":"tutorials/docker-build-strategy/#docker-build-strategy","text":"Docker is a great tool for the CI/CD ecosystem. As the EdgeX DevOps community, we made the decision early when designing the EdgeX Jenkins pipelines to make Docker the center of our build strategy. The advantage of using Docker as the build context is that it allows for creating reproducible builds from Jenkins to our local build environment. Thus creating a portable build environment and minimizing build errors between environments. The EdgeX Jenkins pipelines use Docker images as the context for any build. This Docker image is generated from the Dockerfile.build found at the root of every EdgeX repository. Any dependencies or packages required for testing or compilation needs to be added to the Dockerfile.build file.","title":"Docker Build Strategy"},{"location":"tutorials/docker-build-strategy/#local-testing","text":"If we want to test how the build will run on Jenkins we can follow these steps locally.","title":"Local Testing"},{"location":"tutorials/docker-build-strategy/#example","text":"First we build the \"build image\" edgex-ci-build-image cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build Now we run the build image with some make targets and bind mount our current directory to a folder called /ws (workspace) docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Or to put it into a convenient one-liner: cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build . && docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Sending build context to Docker daemon 127kB Step 1/8 : ARG BASE=golang:1.15-alpine Step 2/8 : FROM ${BASE} ---> 1a87ceb1ace5 Step 3/8 : LABEL license='SPDX-License-Identifier: Apache-2.0' copyright='Copyright (c) 2019: Intel' ---> Using cache ---> 9f1aa172c1d7 Step 4/8 : RUN sed -e 's/dl-cdn[.]alpinelinux.org/nl.alpinelinux.org/g' -i~ /etc/apk/repositories ---> Using cache ---> fec4da09e9ec Step 5/8 : RUN apk add --no-cache make git gcc libc-dev libsodium-dev zeromq-dev bash ... Successfully built ce2be0b9fe31 Successfully tagged edgex-ci-build-image:latest CGO_ENABLED=1 go test -coverprofile=coverage.out ./... ? github.com/edgexfoundry/app-service-configurable [no test files] CGO_ENABLED=1 go build -ldflags \"-X github.com/edgexfoundry/app-functions-sdk-go/internal.SDKVersion=v1.2.1-dev.35 -X github.com/edgexfoundry/app-functions-sdk-go/internal.ApplicationVersion=0.0.0\" app-service-configurable","title":"Example"},{"location":"tutorials/docker-build-strategy/#tooling-caveats","text":"Docker build images are Alpine based to save on disk space and bandwith and with that comes potential tooling incompatiblities. For example a number of pre-installed base packages on Alpine are the BusyBox versions of the tools. BusyBox versions can sometimes have different arguments than their GNU counterparts. For instance the tar command:","title":"Tooling Caveats"},{"location":"tutorials/docker-build-strategy/#busybox-alpine","text":"$ tar --help BusyBox v1.31.1 () multi-call binary. Usage: tar c | x | t [ -ZzJjahmvokO ] [ -f TARFILE ] [ -C DIR ] [ -T FILE ] [ -X FILE ] [ --exclude PATTERN ] ... [ FILE ] ...","title":"BusyBox (Alpine)"},{"location":"tutorials/docker-build-strategy/#gnu-other-linux-distros","text":"$ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. This can lead to unexpected issues if say, for instance, you are depending on a specific flag provided by the tool. One option to fix this is to just use the BusyBox flags, however this may break when not running inside the Docker build image. Another option is to find the alternative package and install that version. For example, Alpine provides the GNU alternative tar binary under the tar Alpine package: $ apk add --update tar $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive.","title":"GNU (Other linux distros)"},{"location":"tutorials/docker-build-strategy/#the-jenkins-way","text":"The above example is similar to how Jenkins runs the build with a few distinctions. First, the make test and make build commands are broken up into two stages. This is an important distinction because it allows for a more granular pipeline allowing for better error handling. The other distinction is that Jenkins takes advantage of a caching base layer image that is passed in at build time. Take a look at the Dockerfile.build. You will notice the BASE docker ARG at the top of the file. ARG BASE = golang:1.15-alpine FROM ${BASE} ... This allows Jenkins to override the base image during the build with an image from Nexus helping to alleviate issues with DockerHub pull limits as well as random Docker pull failures. On Jenkins this happens in the Prep stage: docker build -t ci-base-image-x86_64 \\ -f Dockerfile.build \\ --build-arg BASE = nexus3.edgexfoundry.org:10003/edgex-devops/edgex-golang-base:1.15-alpine \\ . The DevOps WG team manages these Golang base images and the Dockerfile for the latest Golang image used can be found here: https://github.com/edgexfoundry/ci-build-images/tree/golang-1.15 . This cache image contains most of the dependencies used in the majority of the pipelines allowing us to cache dependencies at the base image level and increasing builds speeds. After the base image is built the test and build stages run in a similar manner to the local testing scenario: docker run -t -u 0:0 \\ -w /w/workspace/app-service-configurable/60 \\ -v /w/workspace/app-service-configurable/60:/w/workspace/app-service-configurable/60:rw,z \\ -v /w/workspace/app-service-configurable/60@tmp:/w/workspace/app-service-configurable/60@tmp:rw,z \\ ci-base-image-x86_64 ... make test","title":"The Jenkins Way"},{"location":"tutorials/docker-build-strategy/#next-steps","text":"More information can be found by reading the documentation or source code of these pipelines: edgeXBuildGoApp source edgeXBuildGoParallel source","title":"Next steps"},{"location":"tutorials/manual-bump/","text":"Manual Version Bump Process Sometimes the version of the edgex-global-pipelines needs to be changed between stable and experimental tags in order to enhance and validate that the changes work as expected. The process documented here outlines the manual process for bumping the version and tag on the global libraries. Committer Access Required You must have write access to the repo to perform this manual version bump process. - Developer must be a member of the devops-core-team as per TSC approval - Version info can be obtained through view of the Jenkins Pipeline log for last successful build $ git clone git@github.com:edgexfoundry/edgex-global-pipelines.git $ cd edgex-global-pipelines $ ./resources/update-named-tag.sh <version> <stable | experimental> Click on image below to view ASCII recording of the manual version bump process","title":"Manual Version Bump Process"},{"location":"tutorials/manual-bump/#manual-version-bump-process","text":"Sometimes the version of the edgex-global-pipelines needs to be changed between stable and experimental tags in order to enhance and validate that the changes work as expected. The process documented here outlines the manual process for bumping the version and tag on the global libraries.","title":"Manual Version Bump Process"},{"location":"tutorials/manual-bump/#committer-access-required","text":"You must have write access to the repo to perform this manual version bump process. - Developer must be a member of the devops-core-team as per TSC approval - Version info can be obtained through view of the Jenkins Pipeline log for last successful build $ git clone git@github.com:edgexfoundry/edgex-global-pipelines.git $ cd edgex-global-pipelines $ ./resources/update-named-tag.sh <version> <stable | experimental>","title":"Committer Access Required"},{"location":"tutorials/manual-bump/#click-on-image-below-to-view-ascii-recording-of-the-manual-version-bump-process","text":"","title":"Click on image below to view ASCII recording of the manual version bump process"},{"location":"tutorials/pr-commit-for-testing/","text":"Pull Request Sandbox Testing Introduction The EdgeX Jenkins Production Server and EdgeX Jenkins Sandbox Server are configured to use the edgex-global-pipelines library. The servers target either stable or experimental tags for Production and Sandbox servers respectively. To make functional testing of Jenkins Shared Pipeline Libraries more convenient, you can use a commit hash from a Pull Request into edgex-global-pipelines to override the default pipeline version that the Jenkins server is using. ( stable / experimental ) Step 1 - Create Draft PR When you have changes you'd like to functionally test, open a Draft Pull Request from your forked repository of edgex-global-pipelines into edgex-global-pipelines:master Make clear that this is a PR for functional testing purposes and is not meant to be merged. Step 2 - Use PR Commit Hash Find the commit hash of your draft PR. Place the commit hash into your Jenkinsfile that is under test. The EdgeX Sample-Service is a good place to functionally test shared libraries without affecting production code. Add the commit hash after the '@' in the explicit library import statement as shown below. @Library ( \"edgex-global-pipelines@7eba319\" ) _ edgeXBuildGoApp ( project: 'sample-service' , goVersion: '1.15' , buildExperimentalDockerImage: true ) Step 3 - Execute Jenkinsfile When you execute your functional test build job on the sandbox, the commit hash of your PR will be shown as the commit used for the edgex-global-pipeline shared library. You will see a message similar to the following in your build job console output. ... Loading library edgex-global-pipelines@7eba319 Attempting to resolve 7eba319 from remote references... ... Step 4 - Finishing Up When you are satisfied that the content of your edgex-global-pipelines fork is functionally tested and ready to be merged, you can convert your draft PR into a real PR and add the appropriate reviewers. After your PR is merged to master, the experimental tag will point to your newest content. You might want to test your new code by switching back to the experimental tag in your Jenkinsfile. @Library ( \"edgex-global-pipelines@experimental\" ) _ Please clean up and close your PR after you have finished your functional testing.","title":"Pull Request Sandbox Testing"},{"location":"tutorials/pr-commit-for-testing/#pull-request-sandbox-testing","text":"","title":"Pull Request Sandbox Testing"},{"location":"tutorials/pr-commit-for-testing/#introduction","text":"The EdgeX Jenkins Production Server and EdgeX Jenkins Sandbox Server are configured to use the edgex-global-pipelines library. The servers target either stable or experimental tags for Production and Sandbox servers respectively. To make functional testing of Jenkins Shared Pipeline Libraries more convenient, you can use a commit hash from a Pull Request into edgex-global-pipelines to override the default pipeline version that the Jenkins server is using. ( stable / experimental )","title":"Introduction"},{"location":"tutorials/pr-commit-for-testing/#step-1-create-draft-pr","text":"When you have changes you'd like to functionally test, open a Draft Pull Request from your forked repository of edgex-global-pipelines into edgex-global-pipelines:master Make clear that this is a PR for functional testing purposes and is not meant to be merged.","title":"Step 1 - Create Draft PR"},{"location":"tutorials/pr-commit-for-testing/#step-2-use-pr-commit-hash","text":"Find the commit hash of your draft PR. Place the commit hash into your Jenkinsfile that is under test. The EdgeX Sample-Service is a good place to functionally test shared libraries without affecting production code. Add the commit hash after the '@' in the explicit library import statement as shown below. @Library ( \"edgex-global-pipelines@7eba319\" ) _ edgeXBuildGoApp ( project: 'sample-service' , goVersion: '1.15' , buildExperimentalDockerImage: true )","title":"Step 2 - Use PR Commit Hash"},{"location":"tutorials/pr-commit-for-testing/#step-3-execute-jenkinsfile","text":"When you execute your functional test build job on the sandbox, the commit hash of your PR will be shown as the commit used for the edgex-global-pipeline shared library. You will see a message similar to the following in your build job console output. ... Loading library edgex-global-pipelines@7eba319 Attempting to resolve 7eba319 from remote references... ...","title":"Step 3 - Execute Jenkinsfile"},{"location":"tutorials/pr-commit-for-testing/#step-4-finishing-up","text":"When you are satisfied that the content of your edgex-global-pipelines fork is functionally tested and ready to be merged, you can convert your draft PR into a real PR and add the appropriate reviewers. After your PR is merged to master, the experimental tag will point to your newest content. You might want to test your new code by switching back to the experimental tag in your Jenkinsfile. @Library ( \"edgex-global-pipelines@experimental\" ) _ Please clean up and close your PR after you have finished your functional testing.","title":"Step 4 - Finishing Up"},{"location":"tutorials/unit-testing-best-practices/","text":"Unit Testing Best Practices Table Of Contents Unit Testing Declarative Pipelines Encapsulate Pipeline logic within Groovy functions Example Mocking Jenkins Dependencies Add plugin dependency to Gradle Mocking Environment Variables Testing environment variables Mock external shared library methods Integration Testing Mock errors Mock external shared library methods Call Graph Example References Unit Testing Declarative Pipelines The edgex-global-pipelines shared library leverages the Jenkins Spock framework for unit testing Jenkins pipeline scripts and functions. The Jenkins Spock unit test framework does not currently support unit testing of Jenkins Declarative Pipeline code . Encapsulate Pipeline logic within Groovy functions In order to facilitate unit testing of the edgex-global-pipelines shared library, the DevOps team has made a deliberate effort to to minimize the amount of scripting logic contained within Jenkins declarative pipelines. This is accomplished by encapsulating pipeline logic within a Groovy function and calling the function in the declarative pipeline step as needed. Localizing pipeline logic within Groovy functions enables the Jenkins Spock framework to provide greater test coverage of Pipeline logic. Example An example this approach can be seen within the Build -> amd64 -> Prep stage of the edgeXBuildCApp Delcarative Pipeline . Note the logic for prepping the base build image is encapsulated into a method named prepBaseBuildImage and it is called within the declarative Pipeline. Also the prepBaseBuildImage function logic is thoroughly unit tested in the edgeXBuildCApp Spec Mocking Jenkins Dependencies Always leverage the builtin capabilities of the Jenkins-Spock framework for mocking Jenkins plugins. For example, if you come across the following error when unit testing your code: java.lang.IllegalStateException: During a test, the pipeline step [stepName] was called but there was no mock for it. The error above denotes that the code under test calls a pipeline step stepName but there is no mock for it. You are able to explicitly mock the pipeline step using explictlyMockPipelineStep method available in the Jenkins-Spock framework. However it is recommended that the plugin that contains the corresponding step be added as a dependency in the build.gradle file. For instructions on how to do this, refer to the Add plugin dependency to Gradle section. Add plugin dependency to Gradle Note the name of the Pipeline Step to add. Go to Pipeline Steps Reference page. Use your browser and search for the Pipeline Step within the page. If the Pipeline Step is found, click on the Pipeline that it belongs to, the page for the respective Pipeline should open. Under the heading click on the View this plugin on the Plugins site link, the plugins.jenkins.io page should open. In the plugins.jenkins.io page note the ID for the Pipeline. You will use this ID in the next step. Go to Maven Repository page. Enter the ID in the search, and locate the result from the results displayed, click on the respective link. In the page, click on the Jenkins Releases tab. If you know the version then click it, otherwise click on the latest version that is listed. In the Gradle tab, note the group, name and version. Edit the build.gradle file, add the dependency found above to the dependencies section. Mocking Environment Variables Always ensure the source code under test uses one of the following idioms for getting or setting Environment Variables, doing this will simplify the ability to mock environment variables in the unit test: - Getting the value of an environment variable - env.VARIABLE - env[VARIABLE] - \"${env.VARIABLE}\" - Setting the value of an environment variable - env.VARIABLE = VALUE - env[VARIABLE] = VALUE Testing environment variables Within your unit tests, environment variables are set using the .getBinding().setVariable('name', 'value') idiom. Where the name is env and the value is a map you define within your unit test. The map should define all environment variables the code under test expects, likewise the map can be used to assert any environment variables that the code under test sets. A good example of this practice is the EdgeXSetupEnvironmentSpec Mock external shared library methods The edgex-global-pipelines Jenkins shared library consists of multiple scripts exposing methods for various functional areas, where each script is named after the particular functional area it serves. The shared library includes a EdgeX script that serves as utility script containing methods that are shared amongst other scripts. It is common practice for a method in one script call a method in another script, to mock the interaction you use the explictlyMockPipelineVariable to mock the script, then getPipelineMock method to verify the interaction or stub it if necessary. Mock the external script named script : explictlyMockPipelineVariable('script') It is recommended to mock all external scripts called within the script under test in the Test Spec setup. Get the script mock and stub the call to method to return 'value' for any argument passed in: getPipelineMock('script.method').call(_) >> 'value' Integration Testing Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group. The Jenkins-Spock framework provides the ability to load any number of scripts to test within a given Spec Test. There are instances where performing integration tests is more practical, if you wish to do so then we recommend naming the Spec Test with Int as to differentiate between unit and integration tests. A good example of this practice is the EdgeXReleaseDockerImageIntSpec Mock errors Always leverage error when wanting to conditionally abort part of your script. Error is a Pipeline Step whose plugin has been added as a dependency to our project thus is already mocked by the framework. An example showing how you can assert that an error is thrown with a specific message: 1 * getPipelineMock('error').call('error message') Mock external shared library methods The difficulties of mocking functions within the same script under test have been described in the following issue: Issue 78 . Due to the nature of how the scripts that comprise the edgex-global-pipelines shared library are written; where a deliberate intent is made to develop small, functionally cohesive methods that contribute to a single well-defined task. This development intent results in having scripts with multi-layered call graphs, where methods may call multiple methods from within the same script. We find that the workaround provided in the issue is complicated and doesn't scale well in our environment. For these reasons the method outlined below is being suggested. For the script under test, document its call graph. A call graph is a control flow graph, which represents calling relationships between methods in a script or program. Each node represents a method and each edge (f, g) indicates that method f calls method g. An example EdgeXReleaseGitTag call graph is depicted below. Create a second script with the same name as the original script with the word Util added to the end, for example EdgeXReleaseGitTagUtil.groovy . Analyze the call graph, methods that reside in odd numbered layers should continue to reside in the first script, methods at even numbered layers should be moved from the first script into the second script. Create a Spec Test for both scripts. Mocking of methods between both scripts follow the same pattern described for Mock external shared library methods . The only difference with this approach is that the scripts are (for the lack of a better word) name spaced for the respective functional area. Call Graph Example NOTE The approach outlined above is not recommended as the standard development approach, but as an alternative to re-writing the script under test if mocking of the internal method calls becomes unwieldy. References Jenkins Spock Documentation Spock Framework Reference Jenkins Shared Libraries","title":"Unit Testing Best Practices"},{"location":"tutorials/unit-testing-best-practices/#unit-testing-best-practices","text":"","title":"Unit Testing Best Practices"},{"location":"tutorials/unit-testing-best-practices/#table-of-contents","text":"Unit Testing Declarative Pipelines Encapsulate Pipeline logic within Groovy functions Example Mocking Jenkins Dependencies Add plugin dependency to Gradle Mocking Environment Variables Testing environment variables Mock external shared library methods Integration Testing Mock errors Mock external shared library methods Call Graph Example References","title":"Table Of Contents"},{"location":"tutorials/unit-testing-best-practices/#unit-testing-declarative-pipelines","text":"The edgex-global-pipelines shared library leverages the Jenkins Spock framework for unit testing Jenkins pipeline scripts and functions. The Jenkins Spock unit test framework does not currently support unit testing of Jenkins Declarative Pipeline code .","title":"Unit Testing Declarative Pipelines"},{"location":"tutorials/unit-testing-best-practices/#encapsulate-pipeline-logic-within-groovy-functions","text":"In order to facilitate unit testing of the edgex-global-pipelines shared library, the DevOps team has made a deliberate effort to to minimize the amount of scripting logic contained within Jenkins declarative pipelines. This is accomplished by encapsulating pipeline logic within a Groovy function and calling the function in the declarative pipeline step as needed. Localizing pipeline logic within Groovy functions enables the Jenkins Spock framework to provide greater test coverage of Pipeline logic.","title":"Encapsulate Pipeline logic within Groovy functions"},{"location":"tutorials/unit-testing-best-practices/#example","text":"An example this approach can be seen within the Build -> amd64 -> Prep stage of the edgeXBuildCApp Delcarative Pipeline . Note the logic for prepping the base build image is encapsulated into a method named prepBaseBuildImage and it is called within the declarative Pipeline. Also the prepBaseBuildImage function logic is thoroughly unit tested in the edgeXBuildCApp Spec","title":"Example"},{"location":"tutorials/unit-testing-best-practices/#mocking-jenkins-dependencies","text":"Always leverage the builtin capabilities of the Jenkins-Spock framework for mocking Jenkins plugins. For example, if you come across the following error when unit testing your code: java.lang.IllegalStateException: During a test, the pipeline step [stepName] was called but there was no mock for it. The error above denotes that the code under test calls a pipeline step stepName but there is no mock for it. You are able to explicitly mock the pipeline step using explictlyMockPipelineStep method available in the Jenkins-Spock framework. However it is recommended that the plugin that contains the corresponding step be added as a dependency in the build.gradle file. For instructions on how to do this, refer to the Add plugin dependency to Gradle section.","title":"Mocking Jenkins Dependencies"},{"location":"tutorials/unit-testing-best-practices/#add-plugin-dependency-to-gradle","text":"Note the name of the Pipeline Step to add. Go to Pipeline Steps Reference page. Use your browser and search for the Pipeline Step within the page. If the Pipeline Step is found, click on the Pipeline that it belongs to, the page for the respective Pipeline should open. Under the heading click on the View this plugin on the Plugins site link, the plugins.jenkins.io page should open. In the plugins.jenkins.io page note the ID for the Pipeline. You will use this ID in the next step. Go to Maven Repository page. Enter the ID in the search, and locate the result from the results displayed, click on the respective link. In the page, click on the Jenkins Releases tab. If you know the version then click it, otherwise click on the latest version that is listed. In the Gradle tab, note the group, name and version. Edit the build.gradle file, add the dependency found above to the dependencies section.","title":"Add plugin dependency to Gradle"},{"location":"tutorials/unit-testing-best-practices/#mocking-environment-variables","text":"Always ensure the source code under test uses one of the following idioms for getting or setting Environment Variables, doing this will simplify the ability to mock environment variables in the unit test: - Getting the value of an environment variable - env.VARIABLE - env[VARIABLE] - \"${env.VARIABLE}\" - Setting the value of an environment variable - env.VARIABLE = VALUE - env[VARIABLE] = VALUE","title":"Mocking Environment Variables"},{"location":"tutorials/unit-testing-best-practices/#testing-environment-variables","text":"Within your unit tests, environment variables are set using the .getBinding().setVariable('name', 'value') idiom. Where the name is env and the value is a map you define within your unit test. The map should define all environment variables the code under test expects, likewise the map can be used to assert any environment variables that the code under test sets. A good example of this practice is the EdgeXSetupEnvironmentSpec","title":"Testing environment variables"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods","text":"The edgex-global-pipelines Jenkins shared library consists of multiple scripts exposing methods for various functional areas, where each script is named after the particular functional area it serves. The shared library includes a EdgeX script that serves as utility script containing methods that are shared amongst other scripts. It is common practice for a method in one script call a method in another script, to mock the interaction you use the explictlyMockPipelineVariable to mock the script, then getPipelineMock method to verify the interaction or stub it if necessary. Mock the external script named script : explictlyMockPipelineVariable('script') It is recommended to mock all external scripts called within the script under test in the Test Spec setup. Get the script mock and stub the call to method to return 'value' for any argument passed in: getPipelineMock('script.method').call(_) >> 'value'","title":"Mock external shared library methods"},{"location":"tutorials/unit-testing-best-practices/#integration-testing","text":"Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group. The Jenkins-Spock framework provides the ability to load any number of scripts to test within a given Spec Test. There are instances where performing integration tests is more practical, if you wish to do so then we recommend naming the Spec Test with Int as to differentiate between unit and integration tests. A good example of this practice is the EdgeXReleaseDockerImageIntSpec","title":"Integration Testing"},{"location":"tutorials/unit-testing-best-practices/#mock-errors","text":"Always leverage error when wanting to conditionally abort part of your script. Error is a Pipeline Step whose plugin has been added as a dependency to our project thus is already mocked by the framework. An example showing how you can assert that an error is thrown with a specific message: 1 * getPipelineMock('error').call('error message')","title":"Mock errors"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods_1","text":"The difficulties of mocking functions within the same script under test have been described in the following issue: Issue 78 . Due to the nature of how the scripts that comprise the edgex-global-pipelines shared library are written; where a deliberate intent is made to develop small, functionally cohesive methods that contribute to a single well-defined task. This development intent results in having scripts with multi-layered call graphs, where methods may call multiple methods from within the same script. We find that the workaround provided in the issue is complicated and doesn't scale well in our environment. For these reasons the method outlined below is being suggested. For the script under test, document its call graph. A call graph is a control flow graph, which represents calling relationships between methods in a script or program. Each node represents a method and each edge (f, g) indicates that method f calls method g. An example EdgeXReleaseGitTag call graph is depicted below. Create a second script with the same name as the original script with the word Util added to the end, for example EdgeXReleaseGitTagUtil.groovy . Analyze the call graph, methods that reside in odd numbered layers should continue to reside in the first script, methods at even numbered layers should be moved from the first script into the second script. Create a Spec Test for both scripts. Mocking of methods between both scripts follow the same pattern described for Mock external shared library methods . The only difference with this approach is that the scripts are (for the lack of a better word) name spaced for the respective functional area.","title":"Mock external shared library methods"},{"location":"tutorials/unit-testing-best-practices/#call-graph-example","text":"NOTE The approach outlined above is not recommended as the standard development approach, but as an alternative to re-writing the script under test if mocking of the internal method calls becomes unwieldy.","title":"Call Graph Example"},{"location":"tutorials/unit-testing-best-practices/#references","text":"Jenkins Spock Documentation Spock Framework Reference Jenkins Shared Libraries","title":"References"}]}