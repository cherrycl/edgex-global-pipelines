{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EdgeX Global Pipelines Summary This repository contains useful Jenkins global library functions used within the EdgeX Jenkins ecosystem. It provides pre-built pipelines to build and publish Go/C++ based source code in a consistent manner. There are also a lot of utility functions that allow for things like automated vulnerability scanning via Snyk, code coverage tracking via CodeCov.io and many other things. Below you will find some useful links as well as links to all of our documented pipelines. Please note: Documentation is still under heavy development. Useful Links Source Code EdgeX Jenkins Server Jenkins Shared Libraries Jenkins Shared Libraries edgeXBuildCApp edgeXBuildDocker edgeXBuildGoApp edgeXBuildGoMod edgeXBuildGoParallel edgeXClair edgeXCodecov edgeXDocker edgeXDockerLogin edgeXEmail edgeXEmailUtil edgeXGHPagesPublish edgeXGeneric edgeXInfraLFToolsSign edgeXInfraPublish edgeXInfraShipLogs edgeXLTS edgeXNexusPublish edgeXRelease edgeXReleaseDockerImage edgeXReleaseDocs edgeXReleaseGitHubAssets edgeXReleaseGitTag edgeXReleaseGitTagUtil edgeXReleaseSnap edgeXSemver edgeXSetupEnvironment edgeXSnap edgeXSnyk edgeXSwaggerPublish edgeXUpdateNamedTag edgex","title":"EdgeX Global Pipelines"},{"location":"#edgex-global-pipelines","text":"","title":"EdgeX Global Pipelines"},{"location":"#summary","text":"This repository contains useful Jenkins global library functions used within the EdgeX Jenkins ecosystem. It provides pre-built pipelines to build and publish Go/C++ based source code in a consistent manner. There are also a lot of utility functions that allow for things like automated vulnerability scanning via Snyk, code coverage tracking via CodeCov.io and many other things. Below you will find some useful links as well as links to all of our documented pipelines. Please note: Documentation is still under heavy development.","title":"Summary"},{"location":"#useful-links","text":"Source Code EdgeX Jenkins Server Jenkins Shared Libraries","title":"Useful Links"},{"location":"#jenkins-shared-libraries","text":"edgeXBuildCApp edgeXBuildDocker edgeXBuildGoApp edgeXBuildGoMod edgeXBuildGoParallel edgeXClair edgeXCodecov edgeXDocker edgeXDockerLogin edgeXEmail edgeXEmailUtil edgeXGHPagesPublish edgeXGeneric edgeXInfraLFToolsSign edgeXInfraPublish edgeXInfraShipLogs edgeXLTS edgeXNexusPublish edgeXRelease edgeXReleaseDockerImage edgeXReleaseDocs edgeXReleaseGitHubAssets edgeXReleaseGitTag edgeXReleaseGitTagUtil edgeXReleaseSnap edgeXSemver edgeXSetupEnvironment edgeXSnap edgeXSnyk edgeXSwaggerPublish edgeXUpdateNamedTag edgex","title":"Jenkins Shared Libraries"},{"location":"libraries/edgeXBuildCApp/","text":"edgeXBuildCApp Shared Library to build C projects Overview Parameters Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build dockerBaseImage optional str The docker base image for your project. Default : nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false. Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64'] Usage Basic example edgeXBuildCApp ( project: 'device-bacnet-c' ) Complex example edgeXBuildCApp ( project: 'device-sdk-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.11-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.11' , testScript: 'apk add --update --no-cache openssl ca-certificates && make test' , pushImage: false ) Full example This example shows all the settings that can be specified and their default values. edgeXBuildCApp ( project: 'c-project' , mavenSettings: 'c-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , dockerBaseImage: 'nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest' , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-c-project' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"edgeXBuildCApp"},{"location":"libraries/edgeXBuildCApp/#edgexbuildcapp","text":"Shared Library to build C projects","title":"edgeXBuildCApp"},{"location":"libraries/edgeXBuildCApp/#overview","text":"","title":"Overview"},{"location":"libraries/edgeXBuildCApp/#parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build dockerBaseImage optional str The docker base image for your project. Default : nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false. Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64']","title":"Parameters"},{"location":"libraries/edgeXBuildCApp/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildCApp/#basic-example","text":"edgeXBuildCApp ( project: 'device-bacnet-c' )","title":"Basic example"},{"location":"libraries/edgeXBuildCApp/#complex-example","text":"edgeXBuildCApp ( project: 'device-sdk-c' , dockerBuildFilePath: 'scripts/Dockerfile.alpine-3.11-base' , dockerFilePath: 'scripts/Dockerfile.alpine-3.11' , testScript: 'apk add --update --no-cache openssl ca-certificates && make test' , pushImage: false )","title":"Complex example"},{"location":"libraries/edgeXBuildCApp/#full-example","text":"This example shows all the settings that can be specified and their default values. edgeXBuildCApp ( project: 'c-project' , mavenSettings: 'c-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , dockerBaseImage: 'nexus3.edgexfoundry.org:10003/edgex-devops/edgex-gcc-base:latest' , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-c-project' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"Full example"},{"location":"libraries/edgeXBuildDocker/","text":"edgeXBuildDocker Shared Library to build docker images Overview Parameters Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerTags optional str The tag name for your docker image. Default : [] dockerPushLatest optional str Specify if Jenkins should push the docker image with latest tag. Default : true dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true archiveImage optional bool Specify if the built image need to be archived. Default : false archiveName optional bool The name of the archived image. Default : ${_projectName}-archive.tar.gz semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre releaseBranchOverride optional str Specify if you want to override the release branch. failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64'] Usage Basic example edgeXBuildDocker ( project: 'docker-edgex-consul' , dockerImageName: 'docker-edgex-consul' , semver: true ) Complex example edgeXBuildDocker ( project: 'edgex-compose' , mavenSettings: 'ci-build-images-settings' , dockerImageName: 'custom-edgex-compose' , dockerNamespace: 'edgex-devops' , dockerNexusRepo: 'snapshots' , dockerTags: [ \"1.24.1\" ], releaseBranchOverride: 'edgex-compose' ) Full example This example shows all the settings that can be specified and their default values. edgeXBuildDocker ( project: 'sample-project' , mavenSettings: 'sample-project-settings' , semver: true , dockerFilePath: 'Dockerfile' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-sample-project' , dockerTags: [], dockerPushLatest: true , dockerNexusRepo: 'staging' , pushImage: true , archiveImage: false , archiveName: sample - project - archive . tar . gz , semverBump: 'pre' , releaseBranchOverride: 'golang' , failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"edgeXBuildDocker"},{"location":"libraries/edgeXBuildDocker/#edgexbuilddocker","text":"Shared Library to build docker images","title":"edgeXBuildDocker"},{"location":"libraries/edgeXBuildDocker/#overview","text":"","title":"Overview"},{"location":"libraries/edgeXBuildDocker/#parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerTags optional str The tag name for your docker image. Default : [] dockerPushLatest optional str Specify if Jenkins should push the docker image with latest tag. Default : true dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true archiveImage optional bool Specify if the built image need to be archived. Default : false archiveName optional bool The name of the archived image. Default : ${_projectName}-archive.tar.gz semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre releaseBranchOverride optional str Specify if you want to override the release branch. failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64']","title":"Parameters"},{"location":"libraries/edgeXBuildDocker/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildDocker/#basic-example","text":"edgeXBuildDocker ( project: 'docker-edgex-consul' , dockerImageName: 'docker-edgex-consul' , semver: true )","title":"Basic example"},{"location":"libraries/edgeXBuildDocker/#complex-example","text":"edgeXBuildDocker ( project: 'edgex-compose' , mavenSettings: 'ci-build-images-settings' , dockerImageName: 'custom-edgex-compose' , dockerNamespace: 'edgex-devops' , dockerNexusRepo: 'snapshots' , dockerTags: [ \"1.24.1\" ], releaseBranchOverride: 'edgex-compose' )","title":"Complex example"},{"location":"libraries/edgeXBuildDocker/#full-example","text":"This example shows all the settings that can be specified and their default values. edgeXBuildDocker ( project: 'sample-project' , mavenSettings: 'sample-project-settings' , semver: true , dockerFilePath: 'Dockerfile' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-sample-project' , dockerTags: [], dockerPushLatest: true , dockerNexusRepo: 'staging' , pushImage: true , archiveImage: false , archiveName: sample - project - archive . tar . gz , semverBump: 'pre' , releaseBranchOverride: 'golang' , failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"Full example"},{"location":"libraries/edgeXBuildGoApp/","text":"edgeXBuildGoApp Shared Library to build Go projects Overview Parameters Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the useAlpineBase parameter to determine the base for the project's CI build image. Default : 1.17 goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the GOPROXY environment variable to control the download source of Go modules. Default : https://nexus3.edgexfoundry.org/repository/go-proxy/ useAlpineBase optional bool Specify if an Alpine-based edgex-golang-base:${goVersion}-alpine image will be used as the base for the project's CI build image. If true, the respective edgex-golang-base image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based go-lang:${goVersion}-alpine DockerHub image will be used. If false, then a non-Alpine go-lang:${goVersion} DockerHub image will be used. Note this parameter is used in conjuction with the goVersion parameter to determine the base for the projects' CI build image. Default : true dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false. Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre semverVersion optional str This parameter isn't currently used and will be removed in a future version. Default : '' buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for swaggerApiFolders is set. Default : false swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation. Default : ['openapi/v1'] failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org buildExperimentalDockerImage optional bool Specify if Jenkins should add an additonal GitHub tag called experimental at the same commit where the semantic version is tagged. Note this feature is currently only used internally for DevOps builds. Default : false artifactTypes optional list A list of types that the Jenkins build will designate as artifacts, valid list values are docker and archive . Note if archive is specified then all tar.gz or zip files that your project build creates in the artifactRoot folder will be archived to Nexus. Default : ['docker'] artifactRoot optional str The path in the Jenkins workspace to designate as the artifact root folder. Note all files written to this directory within your build will be automatically pushed to Nexus when the Jenkins job completes. Default : archives/bin arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64'] Usage Basic example edgeXBuildGoApp ( project: 'device-random-go' , goVersion: '1.16' ) Complex example edgeXBuildGoApp ( project: 'app-functions-sdk-go' , semver: true , goVersion: '1.16' , testScript: 'make test' , buildImage: false , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v2' ] ) Full example This example shows all the settings that can be specified and their default values. edgeXBuildGoApp ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-go-project' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , buildExperimentalDockerImage: false , artifactTypes: [ 'docker' ], artifactRoot: 'archives/bin' , arch: [ 'amd64' , 'arm64' ] )","title":"edgeXBuildGoApp"},{"location":"libraries/edgeXBuildGoApp/#edgexbuildgoapp","text":"Shared Library to build Go projects","title":"edgeXBuildGoApp"},{"location":"libraries/edgeXBuildGoApp/#overview","text":"","title":"Overview"},{"location":"libraries/edgeXBuildGoApp/#parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the useAlpineBase parameter to determine the base for the project's CI build image. Default : 1.17 goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the GOPROXY environment variable to control the download source of Go modules. Default : https://nexus3.edgexfoundry.org/repository/go-proxy/ useAlpineBase optional bool Specify if an Alpine-based edgex-golang-base:${goVersion}-alpine image will be used as the base for the project's CI build image. If true, the respective edgex-golang-base image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based go-lang:${goVersion}-alpine DockerHub image will be used. If false, then a non-Alpine go-lang:${goVersion} DockerHub image will be used. Note this parameter is used in conjuction with the goVersion parameter to determine the base for the projects' CI build image. Default : true dockerFilePath optional str The path to the Dockerfile for your project. Default : Dockerfile dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerBuildArgs optional list The list of additonal arguments to pass to Docker when building the image for your project. Default : [] dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerImageName optional str The name of the Docker image for your project. Default : docker-${project} dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker image dockerImageName will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false. Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre semverVersion optional str This parameter isn't currently used and will be removed in a future version. Default : '' buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for swaggerApiFolders is set. Default : false swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation. Default : ['openapi/v1'] failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org buildExperimentalDockerImage optional bool Specify if Jenkins should add an additonal GitHub tag called experimental at the same commit where the semantic version is tagged. Note this feature is currently only used internally for DevOps builds. Default : false artifactTypes optional list A list of types that the Jenkins build will designate as artifacts, valid list values are docker and archive . Note if archive is specified then all tar.gz or zip files that your project build creates in the artifactRoot folder will be archived to Nexus. Default : ['docker'] artifactRoot optional str The path in the Jenkins workspace to designate as the artifact root folder. Note all files written to this directory within your build will be automatically pushed to Nexus when the Jenkins job completes. Default : archives/bin arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64']","title":"Parameters"},{"location":"libraries/edgeXBuildGoApp/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildGoApp/#basic-example","text":"edgeXBuildGoApp ( project: 'device-random-go' , goVersion: '1.16' )","title":"Basic example"},{"location":"libraries/edgeXBuildGoApp/#complex-example","text":"edgeXBuildGoApp ( project: 'app-functions-sdk-go' , semver: true , goVersion: '1.16' , testScript: 'make test' , buildImage: false , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v2' ] )","title":"Complex example"},{"location":"libraries/edgeXBuildGoApp/#full-example","text":"This example shows all the settings that can be specified and their default values. edgeXBuildGoApp ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-go-project' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , buildExperimentalDockerImage: false , artifactTypes: [ 'docker' ], artifactRoot: 'archives/bin' , arch: [ 'amd64' , 'arm64' ] )","title":"Full example"},{"location":"libraries/edgeXBuildGoMod/","text":"edgeXBuildGoMod Shared Library to build Go projects using Go Modules. It invokes edgeXBuildGoApp with some default parameters. Parameters The parameters are similar to shared Library edgeXBuildGoApp with a few exceptions in default values of some parameters. buildImage: false, pushImage: false, semverBump: 'pre' Note: These parameters are not overridable. Usage Basic example edgeXBuildGoMod ( project: 'go-mod-configuration' ) Full example This example shows all the settings that can be specified and their default values. edgeXBuildGoMod ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-go-project' , dockerNexusRepo: 'staging' , buildImage: false , pushImage: false , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , buildExperimentalDockerImage: false , artifactTypes: [ 'docker' ], artifactRoot: 'archives/bin' , arch: [ 'amd64' , 'arm64' ] )","title":"edgeXBuildGoMod"},{"location":"libraries/edgeXBuildGoMod/#edgexbuildgomod","text":"Shared Library to build Go projects using Go Modules. It invokes edgeXBuildGoApp with some default parameters.","title":"edgeXBuildGoMod"},{"location":"libraries/edgeXBuildGoMod/#parameters","text":"The parameters are similar to shared Library edgeXBuildGoApp with a few exceptions in default values of some parameters. buildImage: false, pushImage: false, semverBump: 'pre' Note: These parameters are not overridable.","title":"Parameters"},{"location":"libraries/edgeXBuildGoMod/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildGoMod/#basic-example","text":"edgeXBuildGoMod ( project: 'go-mod-configuration' )","title":"Basic example"},{"location":"libraries/edgeXBuildGoMod/#full-example","text":"This example shows all the settings that can be specified and their default values. edgeXBuildGoMod ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFilePath: 'Dockerfile' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerBuildArgs: [], dockerNamespace: '' , dockerImageName: 'docker-go-project' , dockerNexusRepo: 'staging' , buildImage: false , pushImage: false , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , buildExperimentalDockerImage: false , artifactTypes: [ 'docker' ], artifactRoot: 'archives/bin' , arch: [ 'amd64' , 'arm64' ] )","title":"Full example"},{"location":"libraries/edgeXBuildGoParallel/","text":"edgeXBuildGoParallel Shared Library to build Go projects and Docker images in parallel. Utilizes docker-compose --parallel to build Docker images found in the workspace. Currently only used for the edgex-go mono-repo. Overview Parameters Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the useAlpineBase parameter to determine the base for the project's CI build image. Default : 1.17 goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the GOPROXY environment variable to control the download source of Go modules. Default : https://nexus3.edgexfoundry.org/repository/go-proxy/ useAlpineBase optional bool Specify if an Alpine-based edgex-golang-base:${goVersion}-alpine image will be used as the base for the project's CI build image. If true, the respective edgex-golang-base image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based go-lang:${goVersion}-alpine DockerHub image will be used. If false, then a non-Alpine go-lang:${goVersion} DockerHub image will be used. Note this parameter is used in conjuction with the goVersion parameter to determine the base for the projects' CI build image. Default : true dockerFileGlobPath optional str The pattern for finding Dockerfiles to build. Note Docker images will be named with the same name as the directory which the Dockerfile was found in with a docker- prefix and -go suffix. Example: docker-<folder>-go Default : cmd/** /Dockerfile dockerImageNamePrefix optional str The prefix to apply to the names of all the Docker images built. Default : docker- dockerImageNameSuffix optional str The suffix to apply to the names of all the Docker images built. Default : -go dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker images will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for swaggerApiFolders is set. Default : false swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation. Default : ['openapi/v1', 'openapi/v2'] failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64'] Usage Basic example edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , ) Complex example edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , testScript: 'make test' , buildScript: 'make build' , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], buildSnap: true ) Full example This example shows all the settings that can be specified and their default values. edgeXBuildGoParallel ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFileGlobPath: 'cmd/** /Dockerfile' , dockerImageNamePrefix: 'docker-' , dockerImageNameSuffix: '-go' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerNamespace: '' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"edgeXBuildGoParallel"},{"location":"libraries/edgeXBuildGoParallel/#edgexbuildgoparallel","text":"Shared Library to build Go projects and Docker images in parallel. Utilizes docker-compose --parallel to build Docker images found in the workspace. Currently only used for the edgex-go mono-repo.","title":"edgeXBuildGoParallel"},{"location":"libraries/edgeXBuildGoParallel/#overview","text":"","title":"Overview"},{"location":"libraries/edgeXBuildGoParallel/#parameters","text":"Name Required Type Description and Default Value project required str The name of your project. mavenSettings optional str The maven settings file in Jenkins that has been created for your project. Note the maven settings file specified must exist in Jenkins in order for your project to build. Default : ${project}-settings semver optional bool Specify if semantic versioning will be used to version your project. Note edgeX utilizes git-semver for semantic versioning. Default : true testScript optional str The command the build will use to test your project. Note the specified test script will execute in the project's CI build container. Default : make test buildScript optional str The command the build will use to build your project. Default : make build goVersion optional str The version of Go to use for building the project's CI build image. Note this parameter is used in conjuction with the useAlpineBase parameter to determine the base for the project's CI build image. Default : 1.17 goProxy optional str The proxy to use when downloading Go modules. The value of this parameter will be set in the GOPROXY environment variable to control the download source of Go modules. Default : https://nexus3.edgexfoundry.org/repository/go-proxy/ useAlpineBase optional bool Specify if an Alpine-based edgex-golang-base:${goVersion}-alpine image will be used as the base for the project's CI build image. If true, the respective edgex-golang-base image should exist in the Nexus snapshot repository, if a matching image is not found in Nexus then an Alpine-based go-lang:${goVersion}-alpine DockerHub image will be used. If false, then a non-Alpine go-lang:${goVersion} DockerHub image will be used. Note this parameter is used in conjuction with the goVersion parameter to determine the base for the projects' CI build image. Default : true dockerFileGlobPath optional str The pattern for finding Dockerfiles to build. Note Docker images will be named with the same name as the directory which the Dockerfile was found in with a docker- prefix and -go suffix. Example: docker-<folder>-go Default : cmd/** /Dockerfile dockerImageNamePrefix optional str The prefix to apply to the names of all the Docker images built. Default : docker- dockerImageNameSuffix optional str The suffix to apply to the names of all the Docker images built. Default : -go dockerBuildFilePath optional str The path to the Dockerfile that will serve as the CI build image for your project. Default : Dockerfile.build dockerBuildContext optional str The path for Docker to use as its build context when building your project. This applies to building both the CI build image and project image. Default : . dockerBuildImageTarget optional str The name of the docker multi-stage-build stage the pipeline will use when building the CI build image. Default : builder dockerNamespace optional str The docker registry namespace to use when publishing Docker images. Note for EdgeX projects images are published to the root of the docker registry and thus the namespace should be empty. Default : '' dockerNexusRepo optional str The name of the Docker Nexus repository where the project Docker images will be published to if pushImage is set. Default : staging buildImage optional bool Specify if Jenkins should build a Docker image for your project. Note if false then pushImage will also be set to false Default : true pushImage optional bool Specify if Jenkins should push your project's image to dockerNexusRepo . Default : true semverBump optional str The semver axis to bump, see git-semver for valid axis values. Default : pre buildSnap optional bool Specify if Jenkins should build a Snap for your project. Note If set, your project must also include a valid snapcraft yaml snap/snapcraft.yaml for Jenkins to attempt to build the Snap. Default : false publishSwaggerDocs optional bool Specify if Jenkins should attempt to publish your projects API documentation to SwaggerHub. Note in order for Jenkins to publish to SwaggerHub you must ensure a valid value for swaggerApiFolders is set. Default : false swaggerApiFolders optional list The list of paths to your projects API Swagger-based documentation. Default : ['openapi/v1', 'openapi/v2'] failureNotify optional str The group emails (comma-delimited) to email when the Jenkins job fails. Default : edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org arch optional array A list of system architectures to target for the build. Possible values are amd64 or arm64 . Default : ['amd64', 'arm64']","title":"Parameters"},{"location":"libraries/edgeXBuildGoParallel/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXBuildGoParallel/#basic-example","text":"edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , )","title":"Basic example"},{"location":"libraries/edgeXBuildGoParallel/#complex-example","text":"edgeXBuildGoParallel ( project: 'edgex-go' , dockerFileGlobPath: 'cmd/** /Dockerfile' , testScript: 'make test' , buildScript: 'make build' , publishSwaggerDocs: true , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], buildSnap: true )","title":"Complex example"},{"location":"libraries/edgeXBuildGoParallel/#full-example","text":"This example shows all the settings that can be specified and their default values. edgeXBuildGoParallel ( project: 'go-project' , mavenSettings: 'go-project-settings' , semver: true , testScript: 'make test' , buildScript: 'make build' , goVersion: '1.16' , goProxy: 'https://nexus3.edgexfoundry.org/repository/go-proxy/' , useAlpineBase: true , dockerFileGlobPath: 'cmd/** /Dockerfile' , dockerImageNamePrefix: 'docker-' , dockerImageNameSuffix: '-go' , dockerBuildFilePath: 'Dockerfile.build' , dockerBuildContext: '.' , dockerNamespace: '' , dockerNexusRepo: 'staging' , buildImage: true , pushImage: true , semverBump: 'pre' , buildSnap: false , publishSwaggerDocs: false , swaggerApiFolders: [ 'openapi/v1' , 'openapi/v2' ], failureNotify: 'edgex-tsc-core@lists.edgexfoundry.org,edgex-tsc-devops@lists.edgexfoundry.org' , arch: [ 'amd64' , 'arm64' ] )","title":"Full example"},{"location":"libraries/edgeXClair/","text":"edgeXClair \u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f Shared library function to scan docker images for vulnerabilities using Klar. Please use edgeXSnyk instead.","title":"edgeXClair"},{"location":"libraries/edgeXClair/#edgexclair","text":"\u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f Shared library function to scan docker images for vulnerabilities using Klar. Please use edgeXSnyk instead.","title":"edgeXClair"},{"location":"libraries/edgeXCodecov/","text":"edgeXCodecov Overview Shared library to publish Codecov results to CodeCov.io Parameters Name Required Type Description and Default Value tokenFile false str Id of managed config file where token is stored. If null or empty, token file is automatically generated with: ${env.PROJECT}-codecov-token Usage edgeXCodecov ( 'sample-service-codecov-token' )","title":"edgeXCodecov"},{"location":"libraries/edgeXCodecov/#edgexcodecov","text":"","title":"edgeXCodecov"},{"location":"libraries/edgeXCodecov/#overview","text":"Shared library to publish Codecov results to CodeCov.io","title":"Overview"},{"location":"libraries/edgeXCodecov/#parameters","text":"Name Required Type Description and Default Value tokenFile false str Id of managed config file where token is stored. If null or empty, token file is automatically generated with: ${env.PROJECT}-codecov-token","title":"Parameters"},{"location":"libraries/edgeXCodecov/#usage","text":"edgeXCodecov ( 'sample-service-codecov-token' )","title":"Usage"},{"location":"libraries/edgeXDocker/","text":"edgeXDocker Overview Shared library that contains convenience functions for interacting with Docker. This shared library contains numerous functions so only a summary will be provided for each given function. If you have further questions about implementation details please refer to the source code . Functions: edgeXDocker.build : Build a docker image from optional baseImage with a set of default: docker build_args, labels, and tags. edgeXDocker.buildInParallel : Build multiple docker images in parallel. This technique utilizes docker-compose to build multiple images using the parallel flag. edgeXDocker.generateDockerComposeForBuild : Supporting function for edgeXDocker.buildInParallel that generates a docker compose file for a given list of docker images. edgeXDocker.generateServiceYaml : Supporting function for edgeXDocker.buildInParallel that generates service level yaml for a specific docker image. edgeXDocker.push : Push a specific docker image and optionally tag it with the latest tag. A nexus repository can also optionally be specified as well as specific tags. edgeXDocker.pushAll : Push all docker images specified in the dockerImages list. To be used in conjunction with the same input format used by edgeXDocker.buildInParallel to push all images. edgeXDocker.getDockerTags : Generates the default set of tags used when pushing all edgex docker images with the edgeXDocker.push function. edgeXDocker.finalImageName : Prepends a docker image with env.DOCKER_REGISTRY_NAMESPACE if defined. edgeXDocker.cleanImageUrl : Returns image url without protocol. edgeXDocker.parse : Reads a docker image url and returns the parsed image object components. edgeXDocker.toImageStr : Returns docker image string from an image object . Parsed image object [ host: hostname if any associated with the image , fullImage: full image name with tag , namespace: namespace of the image if any , image: image name without tag , tag: tag associated with the image if any ]","title":"edgeXDocker"},{"location":"libraries/edgeXDocker/#edgexdocker","text":"","title":"edgeXDocker"},{"location":"libraries/edgeXDocker/#overview","text":"Shared library that contains convenience functions for interacting with Docker. This shared library contains numerous functions so only a summary will be provided for each given function. If you have further questions about implementation details please refer to the source code .","title":"Overview"},{"location":"libraries/edgeXDocker/#functions","text":"edgeXDocker.build : Build a docker image from optional baseImage with a set of default: docker build_args, labels, and tags. edgeXDocker.buildInParallel : Build multiple docker images in parallel. This technique utilizes docker-compose to build multiple images using the parallel flag. edgeXDocker.generateDockerComposeForBuild : Supporting function for edgeXDocker.buildInParallel that generates a docker compose file for a given list of docker images. edgeXDocker.generateServiceYaml : Supporting function for edgeXDocker.buildInParallel that generates service level yaml for a specific docker image. edgeXDocker.push : Push a specific docker image and optionally tag it with the latest tag. A nexus repository can also optionally be specified as well as specific tags. edgeXDocker.pushAll : Push all docker images specified in the dockerImages list. To be used in conjunction with the same input format used by edgeXDocker.buildInParallel to push all images. edgeXDocker.getDockerTags : Generates the default set of tags used when pushing all edgex docker images with the edgeXDocker.push function. edgeXDocker.finalImageName : Prepends a docker image with env.DOCKER_REGISTRY_NAMESPACE if defined. edgeXDocker.cleanImageUrl : Returns image url without protocol. edgeXDocker.parse : Reads a docker image url and returns the parsed image object components. edgeXDocker.toImageStr : Returns docker image string from an image object .","title":"Functions:"},{"location":"libraries/edgeXDocker/#parsed-image-object","text":"[ host: hostname if any associated with the image , fullImage: full image name with tag , namespace: namespace of the image if any , image: image name without tag , tag: tag associated with the image if any ]","title":"Parsed image object"},{"location":"libraries/edgeXDockerLogin/","text":"edgeXDockerLogin Overview Shared library that wraps the Linux Foundation's (LF) docker login script: ./resources/global-jjb/shell/docker-login.sh . The LF Global JJB Docker Login script looks for the following environment variables: $SETTINGS_FILE , $DOCKER_REGISTRY , $REGISTRY_PORTS , $DOCKERHUB_REGISTRY , $DOCKERHUB_EMAIL which this script automatically sets. Based on given config map entries passed in Please refer to the shell script in global-jjb/shell for the usage. Parameters Name Required Type Description and Default Value settingsFile true str Config file Id that contains authentication details to docker registries. Unique to each Edgex repository. dockerRegistry false str Override docker registry to login to. dockerRegistryPorts false str Listing of all the registry ports to login to e.g.: 10001 10002 10003 10004 dockerHubRegistry false str Override docker hub registry. Not commonly used. dockerHubEmail false str Override docker hub email. Not commonly used. Usage edgeXDockerLogin ( settingsFile: 'edgex-repo-settings' )","title":"edgeXDockerLogin"},{"location":"libraries/edgeXDockerLogin/#edgexdockerlogin","text":"","title":"edgeXDockerLogin"},{"location":"libraries/edgeXDockerLogin/#overview","text":"Shared library that wraps the Linux Foundation's (LF) docker login script: ./resources/global-jjb/shell/docker-login.sh . The LF Global JJB Docker Login script looks for the following environment variables: $SETTINGS_FILE , $DOCKER_REGISTRY , $REGISTRY_PORTS , $DOCKERHUB_REGISTRY , $DOCKERHUB_EMAIL which this script automatically sets. Based on given config map entries passed in Please refer to the shell script in global-jjb/shell for the usage.","title":"Overview"},{"location":"libraries/edgeXDockerLogin/#parameters","text":"Name Required Type Description and Default Value settingsFile true str Config file Id that contains authentication details to docker registries. Unique to each Edgex repository. dockerRegistry false str Override docker registry to login to. dockerRegistryPorts false str Listing of all the registry ports to login to e.g.: 10001 10002 10003 10004 dockerHubRegistry false str Override docker hub registry. Not commonly used. dockerHubEmail false str Override docker hub email. Not commonly used.","title":"Parameters"},{"location":"libraries/edgeXDockerLogin/#usage","text":"edgeXDockerLogin ( settingsFile: 'edgex-repo-settings' )","title":"Usage"},{"location":"libraries/edgeXEmail/","text":"edgeXEmail Overview Shared library to send build success/fail emails generated by the edgexEmailUtil.generateEmailTemplate function. Parameters Name Required Type Description and Default Value subject false str Email subject. Default: [${buildStatus}] ${env.JOB_NAME} Build #${env.BUILD_NUMBER} emailTo true str Comma separated list of email address(s) to send email to. Usage edgeXEmail ( emailTo: 'bob@example.com,susan@example.com' )","title":"edgeXEmail"},{"location":"libraries/edgeXEmail/#edgexemail","text":"","title":"edgeXEmail"},{"location":"libraries/edgeXEmail/#overview","text":"Shared library to send build success/fail emails generated by the edgexEmailUtil.generateEmailTemplate function.","title":"Overview"},{"location":"libraries/edgeXEmail/#parameters","text":"Name Required Type Description and Default Value subject false str Email subject. Default: [${buildStatus}] ${env.JOB_NAME} Build #${env.BUILD_NUMBER} emailTo true str Comma separated list of email address(s) to send email to.","title":"Parameters"},{"location":"libraries/edgeXEmail/#usage","text":"edgeXEmail ( emailTo: 'bob@example.com,susan@example.com' )","title":"Usage"},{"location":"libraries/edgeXEmailUtil/","text":"edgeXEmailUtil Overview Shared library to support the edgeXEmail function by returning relevant build information that can be used to generate an email template. Email template can be found here: https://github.com/edgexfoundry/edgex-global-pipelines/tree/main/resources/email Function Overview edgeXEmailUtil.getJobDetailsJson : Extract relevant build details including job information, author, git information, and failure log information and return map of details. edgeXEmailUtil.generateEmailTemplate : Generate HTML email template from given job details usually generated by calling edgeXEmailUtil.getJobDetailsJson() . Email templates utilize mustache templates and leverage mustachejs for rendering. Usage def jobDetails = edgeXEmailUtil . getJobDetailsJson () def emailHtml = edgeXEmailUtil . generateEmailTemplate ( jobDetails ) // do something with emailHtml...","title":"edgeXEmailUtil"},{"location":"libraries/edgeXEmailUtil/#edgexemailutil","text":"","title":"edgeXEmailUtil"},{"location":"libraries/edgeXEmailUtil/#overview","text":"Shared library to support the edgeXEmail function by returning relevant build information that can be used to generate an email template. Email template can be found here: https://github.com/edgexfoundry/edgex-global-pipelines/tree/main/resources/email","title":"Overview"},{"location":"libraries/edgeXEmailUtil/#function-overview","text":"edgeXEmailUtil.getJobDetailsJson : Extract relevant build details including job information, author, git information, and failure log information and return map of details. edgeXEmailUtil.generateEmailTemplate : Generate HTML email template from given job details usually generated by calling edgeXEmailUtil.getJobDetailsJson() . Email templates utilize mustache templates and leverage mustachejs for rendering.","title":"Function Overview"},{"location":"libraries/edgeXEmailUtil/#usage","text":"def jobDetails = edgeXEmailUtil . getJobDetailsJson () def emailHtml = edgeXEmailUtil . generateEmailTemplate ( jobDetails ) // do something with emailHtml...","title":"Usage"},{"location":"libraries/edgeXGHPagesPublish/","text":"edgeXGHPagesPublish Overview Shared library to publish html and other resources to a GitHub pages branch off the main repository (typically gh-pages ). This shared library is typically used in conjunction with mkdocs and after mkdocs generates all the HTML, etc and the calling pipeline stashes the contents into a specific site-contents Jenkins stash. Process The typical documentation build process goes like this: PR is merged into main in upstream repo mkdocs is called to generate final documentation in upstream repo job. site-contents stash is generated in upstream repo job. edgeXGHPagesPublish() is called to publish stash to GitHub pages. Parameters Name Required Type Description and Default Value repoUrl true str Repo URL where GitHub pages are being published (typically in ssh format for Edgex). credentialId false str Jenkins credentialId used to authenticate to git to push contents. Default : edgex-jenkins-ssh ghPagesBranch false str Git branch where GitHub pages are stored. Default : gh-pages stashName false str Stash name that contains generated site contents that will be published. Default : site-contents Usage edgeXGHPagesPublish (( repoUrl: 'git@github.com:edgexfoundry/edgex-docs.git' )","title":"edgeXGHPagesPublish"},{"location":"libraries/edgeXGHPagesPublish/#edgexghpagespublish","text":"","title":"edgeXGHPagesPublish"},{"location":"libraries/edgeXGHPagesPublish/#overview","text":"Shared library to publish html and other resources to a GitHub pages branch off the main repository (typically gh-pages ). This shared library is typically used in conjunction with mkdocs and after mkdocs generates all the HTML, etc and the calling pipeline stashes the contents into a specific site-contents Jenkins stash.","title":"Overview"},{"location":"libraries/edgeXGHPagesPublish/#process","text":"The typical documentation build process goes like this: PR is merged into main in upstream repo mkdocs is called to generate final documentation in upstream repo job. site-contents stash is generated in upstream repo job. edgeXGHPagesPublish() is called to publish stash to GitHub pages.","title":"Process"},{"location":"libraries/edgeXGHPagesPublish/#parameters","text":"Name Required Type Description and Default Value repoUrl true str Repo URL where GitHub pages are being published (typically in ssh format for Edgex). credentialId false str Jenkins credentialId used to authenticate to git to push contents. Default : edgex-jenkins-ssh ghPagesBranch false str Git branch where GitHub pages are stored. Default : gh-pages stashName false str Stash name that contains generated site contents that will be published. Default : site-contents","title":"Parameters"},{"location":"libraries/edgeXGHPagesPublish/#usage","text":"edgeXGHPagesPublish (( repoUrl: 'git@github.com:edgexfoundry/edgex-docs.git' )","title":"Usage"},{"location":"libraries/edgeXGeneric/","text":"edgeXGeneric \u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f edgeXGeneric ([ project: 'edgex-go' , mavenSettings: [ 'edgex-go-codecov-token:CODECOV_TOKEN' ], ( optional ) credentials: [ string ( credentialsId: 'credential-id-here' , variable: 'APIKEY' )], ( optional ) env: [ GOPATH: '/opt/go-custom/go' ], path: [ '/opt/go-custom/go/bin' ], branches: [ '*' : [ pre_build: [ 'shell/install_custom_golang.sh' ], build: [ 'make test raml_verify && make build docker' , 'shell/codecov-uploader.sh' ] ], 'main' : [ post_build: [ 'shell/edgexfoundry-go-docker-push.sh' ] ] ] ])","title":"edgeXGeneric"},{"location":"libraries/edgeXGeneric/#edgexgeneric","text":"\u26a0\ufe0f Deprecated will be removed in a future version. DO NOT USE \u26a0\ufe0f edgeXGeneric ([ project: 'edgex-go' , mavenSettings: [ 'edgex-go-codecov-token:CODECOV_TOKEN' ], ( optional ) credentials: [ string ( credentialsId: 'credential-id-here' , variable: 'APIKEY' )], ( optional ) env: [ GOPATH: '/opt/go-custom/go' ], path: [ '/opt/go-custom/go/bin' ], branches: [ '*' : [ pre_build: [ 'shell/install_custom_golang.sh' ], build: [ 'make test raml_verify && make build docker' , 'shell/codecov-uploader.sh' ] ], 'main' : [ post_build: [ 'shell/edgexfoundry-go-docker-push.sh' ] ] ] ])","title":"edgeXGeneric"},{"location":"libraries/edgeXInfraLFToolsSign/","text":"edgeXInfraLFToolsSign Overview Shared library that wraps signing of git tags or files in a directory using lftools and Sigul . The signing is done inside a docker image managed by the EdgeX DevOps team. Important: Signing git tags, requires the git tag to be an annotated tag. ( git tag -a ) Parameters Name Required Type Description and Default Value sigulConfig false str Config file Id that contains the Sigul config. Default : sigul-config sigulPassword false str Config file Id that contains the Sigul password. Default : sigul-password sigulPKI false str Config file Id that contains the Sigul PKI information. Default : sigul-pki lftoolsImageVersion false str DevOps managed lftools image version tag. Default : 0.23.1-centos7 command true str Command to run. Valid values : dir, git-tag directory true str Required if command is dir . version true str Required if command is git-tag . mode false str lftools sign mode. Default : parallel Usage edgeXInfraLFToolsSign ( command: 'git-tag' , version: 'v2.0.0' ) edgeXInfraLFToolsSign ([ command: 'dir' , directory: 'MyDirectory' ])","title":"edgeXInfraLFToolsSign"},{"location":"libraries/edgeXInfraLFToolsSign/#edgexinfralftoolssign","text":"","title":"edgeXInfraLFToolsSign"},{"location":"libraries/edgeXInfraLFToolsSign/#overview","text":"Shared library that wraps signing of git tags or files in a directory using lftools and Sigul . The signing is done inside a docker image managed by the EdgeX DevOps team. Important: Signing git tags, requires the git tag to be an annotated tag. ( git tag -a )","title":"Overview"},{"location":"libraries/edgeXInfraLFToolsSign/#parameters","text":"Name Required Type Description and Default Value sigulConfig false str Config file Id that contains the Sigul config. Default : sigul-config sigulPassword false str Config file Id that contains the Sigul password. Default : sigul-password sigulPKI false str Config file Id that contains the Sigul PKI information. Default : sigul-pki lftoolsImageVersion false str DevOps managed lftools image version tag. Default : 0.23.1-centos7 command true str Command to run. Valid values : dir, git-tag directory true str Required if command is dir . version true str Required if command is git-tag . mode false str lftools sign mode. Default : parallel","title":"Parameters"},{"location":"libraries/edgeXInfraLFToolsSign/#usage","text":"edgeXInfraLFToolsSign ( command: 'git-tag' , version: 'v2.0.0' ) edgeXInfraLFToolsSign ([ command: 'dir' , directory: 'MyDirectory' ])","title":"Usage"},{"location":"libraries/edgeXInfraPublish/","text":"edgeXInfraPublish Overview Shared library used as a post build stage to publish build artifacts, logs, metrics to EdgeX Nexus server. Parameters Name Required Type Description and Default Value logSettingsFile false str Config file id for settings to authenticate to Nexus to publish build logs. Default: jenkins-log-archives-settings dockerOptimized false str Whether or not to use a docker image when publishing to Nexus. Default: true Usage edgeXInfraPublish () edgeXInfraPublish { logSettingsFile = 'custom-jenkins-log-archives-settings' dockerOptimized = false }","title":"edgeXInfraPublish"},{"location":"libraries/edgeXInfraPublish/#edgexinfrapublish","text":"","title":"edgeXInfraPublish"},{"location":"libraries/edgeXInfraPublish/#overview","text":"Shared library used as a post build stage to publish build artifacts, logs, metrics to EdgeX Nexus server.","title":"Overview"},{"location":"libraries/edgeXInfraPublish/#parameters","text":"Name Required Type Description and Default Value logSettingsFile false str Config file id for settings to authenticate to Nexus to publish build logs. Default: jenkins-log-archives-settings dockerOptimized false str Whether or not to use a docker image when publishing to Nexus. Default: true","title":"Parameters"},{"location":"libraries/edgeXInfraPublish/#usage","text":"edgeXInfraPublish () edgeXInfraPublish { logSettingsFile = 'custom-jenkins-log-archives-settings' dockerOptimized = false }","title":"Usage"},{"location":"libraries/edgeXInfraShipLogs/","text":"edgeXInfraPublish \u26a0\ufe0f Deprecated no longer in use. This has been replace by lfInfraShipLogs . DO NOT USE \u26a0\ufe0f","title":"edgeXInfraPublish"},{"location":"libraries/edgeXInfraShipLogs/#edgexinfrapublish","text":"\u26a0\ufe0f Deprecated no longer in use. This has been replace by lfInfraShipLogs . DO NOT USE \u26a0\ufe0f","title":"edgeXInfraPublish"},{"location":"libraries/edgeXLTS/","text":"edgeXLTS Overview Shared library with helper functions to manage LTS releases. Used as part of the edgeXRelease.groovy pipeline. Functions: edgeXLTS.prepLTS : Prepares a repository for an LTS release. If the repository is Golang based, go vendoring is enabled to support LTS releases. edgeXLTS.getLatestLTSCommitId : Retrieves the latest LTS commit sha from a repository. edgeXLTS.generateLTSCommitMessage : Creates a an LTS commit message for a release. edgeXLTS.prepGoProject : Prepares a Golang based project for an LTS release enable vendoring and removing the vendor directory from the gitignore file.","title":"edgeXLTS"},{"location":"libraries/edgeXLTS/#edgexlts","text":"","title":"edgeXLTS"},{"location":"libraries/edgeXLTS/#overview","text":"Shared library with helper functions to manage LTS releases. Used as part of the edgeXRelease.groovy pipeline.","title":"Overview"},{"location":"libraries/edgeXLTS/#functions","text":"edgeXLTS.prepLTS : Prepares a repository for an LTS release. If the repository is Golang based, go vendoring is enabled to support LTS releases. edgeXLTS.getLatestLTSCommitId : Retrieves the latest LTS commit sha from a repository. edgeXLTS.generateLTSCommitMessage : Creates a an LTS commit message for a release. edgeXLTS.prepGoProject : Prepares a Golang based project for an LTS release enable vendoring and removing the vendor directory from the gitignore file.","title":"Functions:"},{"location":"libraries/edgeXNexusPublish/","text":"edgeXNexusPublish Overview Shared library to publish a ZIP file to a specific nexus repo. Parameters Name Required Type Description and Default Value serverId true str Used to lookup credentials in mavenSettings file. Example: logs , docker , nexus.edgexfoundry.org mavenSettings true str Config file Id to use publish to Nexus. Example: log-settings nexusRepo true str The nexus repository name where you would like to publish your artifacts. nexusPath false str Path on the nexus server where file should be stored. Default: ${env.SILO}/${env.JENKINS_HOSTNAME}/${env.JOB_NAME}/${env.BUILD_NUMBER} zipFilePath true str path to ZIP file, typically in the workspace. Usage edgeXNexusPublish ([ serverId: 'logs' , mavenSettings: 'log-settings' , nexusRepo: 'logs' , zipFilePath: '*.zip' ])","title":"edgeXNexusPublish"},{"location":"libraries/edgeXNexusPublish/#edgexnexuspublish","text":"","title":"edgeXNexusPublish"},{"location":"libraries/edgeXNexusPublish/#overview","text":"Shared library to publish a ZIP file to a specific nexus repo.","title":"Overview"},{"location":"libraries/edgeXNexusPublish/#parameters","text":"Name Required Type Description and Default Value serverId true str Used to lookup credentials in mavenSettings file. Example: logs , docker , nexus.edgexfoundry.org mavenSettings true str Config file Id to use publish to Nexus. Example: log-settings nexusRepo true str The nexus repository name where you would like to publish your artifacts. nexusPath false str Path on the nexus server where file should be stored. Default: ${env.SILO}/${env.JENKINS_HOSTNAME}/${env.JOB_NAME}/${env.BUILD_NUMBER} zipFilePath true str path to ZIP file, typically in the workspace.","title":"Parameters"},{"location":"libraries/edgeXNexusPublish/#usage","text":"edgeXNexusPublish ([ serverId: 'logs' , mavenSettings: 'log-settings' , nexusRepo: 'logs' , zipFilePath: '*.zip' ])","title":"Usage"},{"location":"libraries/edgeXRelease/","text":"edgeXRelease Overview Shared library with helper functions to manage releases. This is the main entry point for all automated releases using the \ud83d\udd17 cd-management/release repository. Required Yaml Name Required Type Description and Default Value name true str Name of the repository that is being released. version true str Semver version to be released. releaseName true str The codename of the release. This is usually used by sub release processes for naming. releaseStream true str What branch the release is being generated from. (This has been superseded by commitId) commitId true str Git Commit SHA to tag or branch for the release. repo true str https git repository url. Example: https://github.com/edgexfoundry/<repo>.git Functions edgeXRelease.collectReleaseYamlFiles : Search through a provided file path and find all the release yaml files to process and parses yaml into a Groovy object using the readYaml function. Default file pattern to search for will be: release/*.yaml . This function will also validate what files have changed in the commit using edgex.didChange and will only release what was changed. edgeXRelease.parallelStepFactory : Returns a Closure to execute the release for all release yaml entries found for the specific commit. edgeXRelease.parallelStepFactoryTransform : Transforms release yaml Groovy object into a Groovy Closure containing all the logic needed to perform the release for the specific repository. edgeXRelease.stageArtifact : If release contains binaries rather than docker images, the binaries need to be staged before the release occurs. This function forces a build of the artifact by triggering the job using the build(job: ..) Jenkins function. edgeXRelease.getBuilderImagesFromReleasedImages : Used to determine what static builder image to use when building a LTS C based repository. Below you can see the transformation. // Given the release of the following 2 docker images: edgeXRelease . getBuilderImagesFromReleasedImages ( 'nexus3.edgexfoundry.org:10004/sample-service-c' ) > nexus3 . edgexfoundry . org : 10002 /sample-service-c-builder-x86_64:jakarta edgeXRelease.getBuilderImagesFromReleasedImages('nexus3.edgexfoundry.org:10004/ sample - service - c - arm64 ' ) > nexus3 . edgexfoundry . org : 10002 / sample - service - c - builder - arm64: jakarta","title":"edgeXRelease"},{"location":"libraries/edgeXRelease/#edgexrelease","text":"","title":"edgeXRelease"},{"location":"libraries/edgeXRelease/#overview","text":"Shared library with helper functions to manage releases. This is the main entry point for all automated releases using the \ud83d\udd17 cd-management/release repository.","title":"Overview"},{"location":"libraries/edgeXRelease/#required-yaml","text":"Name Required Type Description and Default Value name true str Name of the repository that is being released. version true str Semver version to be released. releaseName true str The codename of the release. This is usually used by sub release processes for naming. releaseStream true str What branch the release is being generated from. (This has been superseded by commitId) commitId true str Git Commit SHA to tag or branch for the release. repo true str https git repository url. Example: https://github.com/edgexfoundry/<repo>.git","title":"Required Yaml"},{"location":"libraries/edgeXRelease/#functions","text":"edgeXRelease.collectReleaseYamlFiles : Search through a provided file path and find all the release yaml files to process and parses yaml into a Groovy object using the readYaml function. Default file pattern to search for will be: release/*.yaml . This function will also validate what files have changed in the commit using edgex.didChange and will only release what was changed. edgeXRelease.parallelStepFactory : Returns a Closure to execute the release for all release yaml entries found for the specific commit. edgeXRelease.parallelStepFactoryTransform : Transforms release yaml Groovy object into a Groovy Closure containing all the logic needed to perform the release for the specific repository. edgeXRelease.stageArtifact : If release contains binaries rather than docker images, the binaries need to be staged before the release occurs. This function forces a build of the artifact by triggering the job using the build(job: ..) Jenkins function. edgeXRelease.getBuilderImagesFromReleasedImages : Used to determine what static builder image to use when building a LTS C based repository. Below you can see the transformation. // Given the release of the following 2 docker images: edgeXRelease . getBuilderImagesFromReleasedImages ( 'nexus3.edgexfoundry.org:10004/sample-service-c' ) > nexus3 . edgexfoundry . org : 10002 /sample-service-c-builder-x86_64:jakarta edgeXRelease.getBuilderImagesFromReleasedImages('nexus3.edgexfoundry.org:10004/ sample - service - c - arm64 ' ) > nexus3 . edgexfoundry . org : 10002 / sample - service - c - builder - arm64: jakarta","title":"Functions"},{"location":"libraries/edgeXReleaseDockerImage/","text":"edgeXReleaseDockerImage Overview Shared library with helper functions to manage docker image releases to Nexus release and DockerHub. Required Yaml Name Required Type Description and Default Value dockerImage true str Determines whether or not to trigger this function. docker true array Array of docker images to release. docker.image true str Docker image that is being release. docker.destination true array Array of destination registries where to release the image to. Functions edgeXReleaseDockerImage.getAvaliableTargets : Returns a list of valid release registries. edgeXReleaseDockerImage.isValidReleaseRegistry : Validates registry to ensure we are not pushing images to unknown registries. edgeXReleaseDockerImage.publishDockerImages : Iterates through all release registry targets and pushes images based on validating image exists. edgeXReleaseDockerImage.publishDockerImage : Pulls, re-tags and pushes source image to destination registry. edgeXReleaseDockerImage.validate : Validates release yaml input before any automation is run. edgeXReleaseDockerImage.imageExists : Checks docker registry to see if image exists. Usage Sample Release Yaml version : 1.1.2 releaseStream : main dockerImage : true docker : - image : nexus3.edgexfoundry.org:10004/sample-service destination : - nexus3.edgexfoundry.org:10002/sample-service - docker.io/edgexfoundry/sample-service - image : nexus3.edgexfoundry.org:10004/sample-service-arm64 destination : - nexus3.edgexfoundry.org:10002/sample-service-arm64 - docker.io/edgexfoundry/sample-service-arm64 Groovy Call edgeXReleaseDockerImage ( releaseYaml )","title":"edgeXReleaseDockerImage"},{"location":"libraries/edgeXReleaseDockerImage/#edgexreleasedockerimage","text":"","title":"edgeXReleaseDockerImage"},{"location":"libraries/edgeXReleaseDockerImage/#overview","text":"Shared library with helper functions to manage docker image releases to Nexus release and DockerHub.","title":"Overview"},{"location":"libraries/edgeXReleaseDockerImage/#required-yaml","text":"Name Required Type Description and Default Value dockerImage true str Determines whether or not to trigger this function. docker true array Array of docker images to release. docker.image true str Docker image that is being release. docker.destination true array Array of destination registries where to release the image to.","title":"Required Yaml"},{"location":"libraries/edgeXReleaseDockerImage/#functions","text":"edgeXReleaseDockerImage.getAvaliableTargets : Returns a list of valid release registries. edgeXReleaseDockerImage.isValidReleaseRegistry : Validates registry to ensure we are not pushing images to unknown registries. edgeXReleaseDockerImage.publishDockerImages : Iterates through all release registry targets and pushes images based on validating image exists. edgeXReleaseDockerImage.publishDockerImage : Pulls, re-tags and pushes source image to destination registry. edgeXReleaseDockerImage.validate : Validates release yaml input before any automation is run. edgeXReleaseDockerImage.imageExists : Checks docker registry to see if image exists.","title":"Functions"},{"location":"libraries/edgeXReleaseDockerImage/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXReleaseDockerImage/#sample-release-yaml","text":"version : 1.1.2 releaseStream : main dockerImage : true docker : - image : nexus3.edgexfoundry.org:10004/sample-service destination : - nexus3.edgexfoundry.org:10002/sample-service - docker.io/edgexfoundry/sample-service - image : nexus3.edgexfoundry.org:10004/sample-service-arm64 destination : - nexus3.edgexfoundry.org:10002/sample-service-arm64 - docker.io/edgexfoundry/sample-service-arm64","title":"Sample Release Yaml"},{"location":"libraries/edgeXReleaseDockerImage/#groovy-call","text":"edgeXReleaseDockerImage ( releaseYaml )","title":"Groovy Call"},{"location":"libraries/edgeXReleaseDocs/","text":"edgeXReleaseDocs Overview Shared library with helper functions to manage documentation releases. Currently used by edgex-docs. Required Yaml Name Required Type Description and Default Value docs true str Determines whether or not to trigger this function. docsInfo.nextReleaseVersion true str Next release version to add to the documentation. docsInfo.nextReleaseName true str Next release name to add to the documentation. docsInfo.reviewers true str Who to assign the generated PR's to. Functions edgeXReleaseDocs.publishReleaseBranch : Makes release branch related changes in unique branch then commits release branch. edgeXReleaseDocs.publishVersionChangesPR : Makes version file related changes in unique branch then commits and opens PR. edgeXReleaseDocs.publishSwaggerChangesPR : Makes Swagger related changes in unique branch then commits and opens PR. edgeXReleaseDocs.commitChange : Commits a change to the repo with a given message. edgeXReleaseDocs.createPR : Creates a PR with the GitHub CLI for with a given branch, title, message and reviewers for. Note: This is generic enough to be used in other functions. edgeXReleaseDocs.validate : Validates release yaml input before any automation is run. Usage Sample Release Yaml name : 'edgex-docs' version : '2.2.0' releaseName : 'kamakura' releaseStream : 'main' repo : 'https://github.com/edgexfoundry/edgex-docs.git' commitId : 'c72b16708d6eed9a08be464a432ce22db7d90667' gitTag : false dockerImages : false docs : true docsInfo : nextReleaseVersion : \"2.3.0\" nextReleaseName : levski reviewers : edgex-docs-committers Groovy Call edgeXReleaseDocs ( releaseYaml )","title":"edgeXReleaseDocs"},{"location":"libraries/edgeXReleaseDocs/#edgexreleasedocs","text":"","title":"edgeXReleaseDocs"},{"location":"libraries/edgeXReleaseDocs/#overview","text":"Shared library with helper functions to manage documentation releases. Currently used by edgex-docs.","title":"Overview"},{"location":"libraries/edgeXReleaseDocs/#required-yaml","text":"Name Required Type Description and Default Value docs true str Determines whether or not to trigger this function. docsInfo.nextReleaseVersion true str Next release version to add to the documentation. docsInfo.nextReleaseName true str Next release name to add to the documentation. docsInfo.reviewers true str Who to assign the generated PR's to.","title":"Required Yaml"},{"location":"libraries/edgeXReleaseDocs/#functions","text":"edgeXReleaseDocs.publishReleaseBranch : Makes release branch related changes in unique branch then commits release branch. edgeXReleaseDocs.publishVersionChangesPR : Makes version file related changes in unique branch then commits and opens PR. edgeXReleaseDocs.publishSwaggerChangesPR : Makes Swagger related changes in unique branch then commits and opens PR. edgeXReleaseDocs.commitChange : Commits a change to the repo with a given message. edgeXReleaseDocs.createPR : Creates a PR with the GitHub CLI for with a given branch, title, message and reviewers for. Note: This is generic enough to be used in other functions. edgeXReleaseDocs.validate : Validates release yaml input before any automation is run.","title":"Functions"},{"location":"libraries/edgeXReleaseDocs/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXReleaseDocs/#sample-release-yaml","text":"name : 'edgex-docs' version : '2.2.0' releaseName : 'kamakura' releaseStream : 'main' repo : 'https://github.com/edgexfoundry/edgex-docs.git' commitId : 'c72b16708d6eed9a08be464a432ce22db7d90667' gitTag : false dockerImages : false docs : true docsInfo : nextReleaseVersion : \"2.3.0\" nextReleaseName : levski reviewers : edgex-docs-committers","title":"Sample Release Yaml"},{"location":"libraries/edgeXReleaseDocs/#groovy-call","text":"edgeXReleaseDocs ( releaseYaml )","title":"Groovy Call"},{"location":"libraries/edgeXReleaseGitHubAssets/","text":"edgeXReleaseGitHubAssets Overview Shared library with helper functions to manage GitHub Releases with attached binaries. This function works in conjunction with the docker image generated from \ud83d\udd17 Create GitHub Release to manage GitHub releases. Currently used by edgex-cli. Required Yaml Name Required Type Description and Default Value gitHubRelease true str Determines whether or not to trigger this function. gitHubReleaseAssets true array List of binaries to release along with generated GitHub Release. Functions edgeXReleaseGitHubAssets.getCredentialsId : Return correct PAT based on ENV.SILO to access GitHub api. edgeXReleaseGitHubAssets.getRepoInfo : Extracts pertinent information from repository and returns as Map. edgeXReleaseGitHubAssets.createGitHubRelease : Wraps call to create-github-release to generate GitHub release. edgeXReleaseGitHubAssets.validate : Validates release yaml input before any automation is run. Usage Sample Release Yaml name : 'sample-service' version : 1.1.2 releaseStream : 'main' repo : 'https://github.com/edgexfoundry/sample-service.git' gitHubRelease : true gitHubReleaseAssets : - 'https://nexus-location/asset1' - 'https://nexus-location/asset2' - 'https://nexus-location/asset3' Groovy Call edgeXReleaseGitHubAssets ( releaseYaml )","title":"edgeXReleaseGitHubAssets"},{"location":"libraries/edgeXReleaseGitHubAssets/#edgexreleasegithubassets","text":"","title":"edgeXReleaseGitHubAssets"},{"location":"libraries/edgeXReleaseGitHubAssets/#overview","text":"Shared library with helper functions to manage GitHub Releases with attached binaries. This function works in conjunction with the docker image generated from \ud83d\udd17 Create GitHub Release to manage GitHub releases. Currently used by edgex-cli.","title":"Overview"},{"location":"libraries/edgeXReleaseGitHubAssets/#required-yaml","text":"Name Required Type Description and Default Value gitHubRelease true str Determines whether or not to trigger this function. gitHubReleaseAssets true array List of binaries to release along with generated GitHub Release.","title":"Required Yaml"},{"location":"libraries/edgeXReleaseGitHubAssets/#functions","text":"edgeXReleaseGitHubAssets.getCredentialsId : Return correct PAT based on ENV.SILO to access GitHub api. edgeXReleaseGitHubAssets.getRepoInfo : Extracts pertinent information from repository and returns as Map. edgeXReleaseGitHubAssets.createGitHubRelease : Wraps call to create-github-release to generate GitHub release. edgeXReleaseGitHubAssets.validate : Validates release yaml input before any automation is run.","title":"Functions"},{"location":"libraries/edgeXReleaseGitHubAssets/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXReleaseGitHubAssets/#sample-release-yaml","text":"name : 'sample-service' version : 1.1.2 releaseStream : 'main' repo : 'https://github.com/edgexfoundry/sample-service.git' gitHubRelease : true gitHubReleaseAssets : - 'https://nexus-location/asset1' - 'https://nexus-location/asset2' - 'https://nexus-location/asset3'","title":"Sample Release Yaml"},{"location":"libraries/edgeXReleaseGitHubAssets/#groovy-call","text":"edgeXReleaseGitHubAssets ( releaseYaml )","title":"Groovy Call"},{"location":"libraries/edgeXReleaseGitTag/","text":"edgeXReleaseGitHubTag Overview Shared library with helper functions to create, sign and bump Git tags. Required Yaml Name Required Type Description and Default Value gitTag true str Determines whether or not to trigger this function. semverBumpLevel false str Semver bump level to be used by git-semver. Default: -pre=dev pre Functions edgeXReleaseGitHubTag.cloneRepo : Generic function to properly clone a repository to a specific subfolder. Directory name generated from releaseYaml.name . edgeXReleaseGitHubTag.setAndSignGitTag : Sets up release tag using git-semver from the specified version set in releaseYaml.version . NOTE: git-semver force is used here for impotency in case tag already exists. So existing tags will be overridden. edgeXReleaseGitHubTag.bumpAndPushGitTag : Pushes signed tag and optionally bumps next version. Usage Sample Release Yaml name : 'sample-service' version : '1.1.2' releaseStream : 'main' commitId : '0cc1d67607642c9413e4a80d25a2df35ecc76d41' repo : 'https://github.com/edgexfoundry/sample-service.git' gitTag : true semverBumpLevel : 'patch' #optional Groovy Call edgeXReleaseGitTag ( releaseYaml )","title":"edgeXReleaseGitHubTag"},{"location":"libraries/edgeXReleaseGitTag/#edgexreleasegithubtag","text":"","title":"edgeXReleaseGitHubTag"},{"location":"libraries/edgeXReleaseGitTag/#overview","text":"Shared library with helper functions to create, sign and bump Git tags.","title":"Overview"},{"location":"libraries/edgeXReleaseGitTag/#required-yaml","text":"Name Required Type Description and Default Value gitTag true str Determines whether or not to trigger this function. semverBumpLevel false str Semver bump level to be used by git-semver. Default: -pre=dev pre","title":"Required Yaml"},{"location":"libraries/edgeXReleaseGitTag/#functions","text":"edgeXReleaseGitHubTag.cloneRepo : Generic function to properly clone a repository to a specific subfolder. Directory name generated from releaseYaml.name . edgeXReleaseGitHubTag.setAndSignGitTag : Sets up release tag using git-semver from the specified version set in releaseYaml.version . NOTE: git-semver force is used here for impotency in case tag already exists. So existing tags will be overridden. edgeXReleaseGitHubTag.bumpAndPushGitTag : Pushes signed tag and optionally bumps next version.","title":"Functions"},{"location":"libraries/edgeXReleaseGitTag/#usage","text":"","title":"Usage"},{"location":"libraries/edgeXReleaseGitTag/#sample-release-yaml","text":"name : 'sample-service' version : '1.1.2' releaseStream : 'main' commitId : '0cc1d67607642c9413e4a80d25a2df35ecc76d41' repo : 'https://github.com/edgexfoundry/sample-service.git' gitTag : true semverBumpLevel : 'patch' #optional","title":"Sample Release Yaml"},{"location":"libraries/edgeXReleaseGitTag/#groovy-call","text":"edgeXReleaseGitTag ( releaseYaml )","title":"Groovy Call"},{"location":"libraries/edgeXReleaseGitTagUtil/","text":"edgeXReleaseGitHubTagUtil Overview Shared library with supporting helper functions to manage Git tags. Functions edgeXReleaseGitHubTagUtil.getSSHRepoName : Converts https repo remote to ssh git@github.com: remote. edgeXReleaseGitHubTagUtil.signGitTag : Wrapper around edgeXInfraLFToolsSign that signs git tag for a release. edgeXReleaseGitHubTagUtil.releaseGitTag : Main function that does full end-to-end git tag release. edgeXReleaseGitHubTagUtil.validate : Validates release yaml input before any automation is run.","title":"edgeXReleaseGitHubTagUtil"},{"location":"libraries/edgeXReleaseGitTagUtil/#edgexreleasegithubtagutil","text":"","title":"edgeXReleaseGitHubTagUtil"},{"location":"libraries/edgeXReleaseGitTagUtil/#overview","text":"Shared library with supporting helper functions to manage Git tags.","title":"Overview"},{"location":"libraries/edgeXReleaseGitTagUtil/#functions","text":"edgeXReleaseGitHubTagUtil.getSSHRepoName : Converts https repo remote to ssh git@github.com: remote. edgeXReleaseGitHubTagUtil.signGitTag : Wrapper around edgeXInfraLFToolsSign that signs git tag for a release. edgeXReleaseGitHubTagUtil.releaseGitTag : Main function that does full end-to-end git tag release. edgeXReleaseGitHubTagUtil.validate : Validates release yaml input before any automation is run.","title":"Functions"},{"location":"libraries/edgeXReleaseSnap/","text":"edgeXReleaseSnap \u26a0\ufe0f Deprecated... Snaps are no longer published by EdgeX DevOps. They are now managed by the team at Canonical. DO NOT USE \u26a0\ufe0f","title":"edgeXReleaseSnap"},{"location":"libraries/edgeXReleaseSnap/#edgexreleasesnap","text":"\u26a0\ufe0f Deprecated... Snaps are no longer published by EdgeX DevOps. They are now managed by the team at Canonical. DO NOT USE \u26a0\ufe0f","title":"edgeXReleaseSnap"},{"location":"libraries/edgeXSemver/","text":"edgeXSemver Overview Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the git semver command based on the provided input. Please note: this shared library is responsible for setting the VERSION environment variable during git semver init execution. Parameters Name Required Type Description and Default Value command false str Specify which git semver sub command to run. Example: init , bump , push semverVersion false string Force a specific override version instead of reading the version from the semver branch. Default: <empty string> gitSemverVersion false string What version of the git-semver docker image to use. Default: latest credentials false string Which Jenkins credential to use to authenticate to GitHub and push git tag. Default: edgex-jenkins-ssh Functions edgeXSemver.executeGitSemver : Execute semverCommand via ssh with provided credentials. edgeXSemver.setGitSemverHeadTag : set GITSEMVER_HEAD_TAG to value of HEAD when any of the following conditions are satisfied: An init version is specified and HEAD is tagged with init version. An init version is not specified and HEAD is tagged. edgeXSemver.getCommitTags : Return list of all tags at a specific commit point. Usage Regular init edgeXSemver ( 'init' ) Force specific the semver version to use. edgeXSemver ( 'init' , '2.0.0' ) Bump the semver version using default semver bump level (pre-release). edgeXSemver ( 'bump' )","title":"edgeXSemver"},{"location":"libraries/edgeXSemver/#edgexsemver","text":"","title":"edgeXSemver"},{"location":"libraries/edgeXSemver/#overview","text":"Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the git semver command based on the provided input. Please note: this shared library is responsible for setting the VERSION environment variable during git semver init execution.","title":"Overview"},{"location":"libraries/edgeXSemver/#parameters","text":"Name Required Type Description and Default Value command false str Specify which git semver sub command to run. Example: init , bump , push semverVersion false string Force a specific override version instead of reading the version from the semver branch. Default: <empty string> gitSemverVersion false string What version of the git-semver docker image to use. Default: latest credentials false string Which Jenkins credential to use to authenticate to GitHub and push git tag. Default: edgex-jenkins-ssh","title":"Parameters"},{"location":"libraries/edgeXSemver/#functions","text":"edgeXSemver.executeGitSemver : Execute semverCommand via ssh with provided credentials. edgeXSemver.setGitSemverHeadTag : set GITSEMVER_HEAD_TAG to value of HEAD when any of the following conditions are satisfied: An init version is specified and HEAD is tagged with init version. An init version is not specified and HEAD is tagged. edgeXSemver.getCommitTags : Return list of all tags at a specific commit point.","title":"Functions"},{"location":"libraries/edgeXSemver/#usage","text":"Regular init edgeXSemver ( 'init' ) Force specific the semver version to use. edgeXSemver ( 'init' , '2.0.0' ) Bump the semver version using default semver bump level (pre-release). edgeXSemver ( 'bump' )","title":"Usage"},{"location":"libraries/edgeXSetupEnvironment/","text":"edgeXSetupEnvironment Overview Shared library to setup a build environment given a Map of key value pairs. Some extra environment variables are set to help with the build process including: GIT_BRANCH GIT_COMMIT GIT_BRANCH_CLEAN SHORT_GIT_COMMIT SEMVER_BRANCH SEMVER_PRE_PREFIX Parameters Name Required Type Description and Default Value vars false str A Map of key/value pairs to expose to the Jenkins environment. Usage edgeXSetupEnvironment ([ PROJECT: 'edgex-global-pipelines' ]) ... ... // This will expose an environment variable named `PROJECT` with the value `edgex-global-pipelines` // as well as the extra environment vars mentioned above.","title":"edgeXSetupEnvironment"},{"location":"libraries/edgeXSetupEnvironment/#edgexsetupenvironment","text":"","title":"edgeXSetupEnvironment"},{"location":"libraries/edgeXSetupEnvironment/#overview","text":"Shared library to setup a build environment given a Map of key value pairs. Some extra environment variables are set to help with the build process including: GIT_BRANCH GIT_COMMIT GIT_BRANCH_CLEAN SHORT_GIT_COMMIT SEMVER_BRANCH SEMVER_PRE_PREFIX","title":"Overview"},{"location":"libraries/edgeXSetupEnvironment/#parameters","text":"Name Required Type Description and Default Value vars false str A Map of key/value pairs to expose to the Jenkins environment.","title":"Parameters"},{"location":"libraries/edgeXSetupEnvironment/#usage","text":"edgeXSetupEnvironment ([ PROJECT: 'edgex-global-pipelines' ]) ... ... // This will expose an environment variable named `PROJECT` with the value `edgex-global-pipelines` // as well as the extra environment vars mentioned above.","title":"Usage"},{"location":"libraries/edgeXSnap/","text":"edgeXSnap Overview \u26a0\ufe0f Deprecated Warning... Snaps are no longer being built as part of the Jenkins pipeline. They are being built and tested using GitHub Actions and are managed by the team at Canonical. DO NOT USE \u26a0\ufe0f Wrapper around resources/snap-build.sh script. No parameters required. Usage edgeXSnap ()","title":"edgeXSnap"},{"location":"libraries/edgeXSnap/#edgexsnap","text":"","title":"edgeXSnap"},{"location":"libraries/edgeXSnap/#overview","text":"\u26a0\ufe0f Deprecated Warning... Snaps are no longer being built as part of the Jenkins pipeline. They are being built and tested using GitHub Actions and are managed by the team at Canonical. DO NOT USE \u26a0\ufe0f Wrapper around resources/snap-build.sh script. No parameters required.","title":"Overview"},{"location":"libraries/edgeXSnap/#usage","text":"edgeXSnap ()","title":"Usage"},{"location":"libraries/edgeXSnyk/","text":"edgeXSnyk Overview Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the git semver command based on the provided input. Please note: this shared library is responsible for setting the VERSION environment variable during git semver init execution. Parameters Name Required Type Description and Default Value command false str Specify which Snyk command to run. Possible values: test , monitor . Default: monitor dockerImage false string If scanning a docker image either a local image name or remote image name. dockerFile false string If scanning a docker image, the path to Dockerfile relative to the Jenkins WORKSPACE . severity false string Severity threshold to mark the build as unstable . sendEmail false string Whether or not to send an email of the findings. Default: true emailTo false string Recipient list of who to send the email to. htmlReport false string Whether or not to generate an HTML report of findings. Default: false Usage Test and continuously monitor project dependencies . For Go projects, this is typically the go.mod file: edgeXSnyk () Test docker image for vulnerabilities and output results to Jenkins console: edgeXSnyk ( command: 'test' , dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest' , dockerFile: '<path to Dockerfile>' ) Test docker image for vulnerabilities and send email of findings: edgeXSnyk ( command: 'test' , dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest' , dockerFile: '<path to Dockerfile>' , severity: 'high' , sendEmail: true , emailTo: < email address ( s )>, htmlReport: true )","title":"edgeXSnyk"},{"location":"libraries/edgeXSnyk/#edgexsnyk","text":"","title":"edgeXSnyk"},{"location":"libraries/edgeXSnyk/#overview","text":"Shared library containing a useful set of functions to help with the creation of semantic versioning using the git-semver python library. The main call function builds the git semver command based on the provided input. Please note: this shared library is responsible for setting the VERSION environment variable during git semver init execution.","title":"Overview"},{"location":"libraries/edgeXSnyk/#parameters","text":"Name Required Type Description and Default Value command false str Specify which Snyk command to run. Possible values: test , monitor . Default: monitor dockerImage false string If scanning a docker image either a local image name or remote image name. dockerFile false string If scanning a docker image, the path to Dockerfile relative to the Jenkins WORKSPACE . severity false string Severity threshold to mark the build as unstable . sendEmail false string Whether or not to send an email of the findings. Default: true emailTo false string Recipient list of who to send the email to. htmlReport false string Whether or not to generate an HTML report of findings. Default: false","title":"Parameters"},{"location":"libraries/edgeXSnyk/#usage","text":"Test and continuously monitor project dependencies . For Go projects, this is typically the go.mod file: edgeXSnyk () Test docker image for vulnerabilities and output results to Jenkins console: edgeXSnyk ( command: 'test' , dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest' , dockerFile: '<path to Dockerfile>' ) Test docker image for vulnerabilities and send email of findings: edgeXSnyk ( command: 'test' , dockerImage: 'nexus3.edgexfoundry.org:10004/core-command:latest' , dockerFile: '<path to Dockerfile>' , severity: 'high' , sendEmail: true , emailTo: < email address ( s )>, htmlReport: true )","title":"Usage"},{"location":"libraries/edgeXSwaggerPublish/","text":"edgeXSwaggerPublish Overview Shared library containing methods to publish Swagger API docs up to https://api.swaggerhub.com . NOTE: ${APIKEY} needs to be a pointer to a file with the key. This will need to be set locally from your environment or from Jenkins. Parameters Name Required Type Description and Default Value owner false str Specify Swagger API owner. Default: EdgeXFoundry1 apiFolders true string Space delimited list of folders to publish. swaggerCredentialId false string Config file Id that contains the Swagger API key to allow publishing of API docs. Default: swaggerhub-api-key Usage Publish single folder to Swagger to owner:EdgeXFoundry1 edgeXSwaggerPublish ( apiFolders: 'openapi/v1' ) Publish multiple API folders to Swagger to owner:EdgeXFoundry1 edgeXSwaggerPublish ( apiFolders: 'openapi/v1 openapi/v2' ) Publish single folder to swagger with a customer owner/organization. edgeXSwaggerPublish ( owner: 'customOwner' , apiFolders: 'openapi/v1' )","title":"edgeXSwaggerPublish"},{"location":"libraries/edgeXSwaggerPublish/#edgexswaggerpublish","text":"","title":"edgeXSwaggerPublish"},{"location":"libraries/edgeXSwaggerPublish/#overview","text":"Shared library containing methods to publish Swagger API docs up to https://api.swaggerhub.com . NOTE: ${APIKEY} needs to be a pointer to a file with the key. This will need to be set locally from your environment or from Jenkins.","title":"Overview"},{"location":"libraries/edgeXSwaggerPublish/#parameters","text":"Name Required Type Description and Default Value owner false str Specify Swagger API owner. Default: EdgeXFoundry1 apiFolders true string Space delimited list of folders to publish. swaggerCredentialId false string Config file Id that contains the Swagger API key to allow publishing of API docs. Default: swaggerhub-api-key","title":"Parameters"},{"location":"libraries/edgeXSwaggerPublish/#usage","text":"Publish single folder to Swagger to owner:EdgeXFoundry1 edgeXSwaggerPublish ( apiFolders: 'openapi/v1' ) Publish multiple API folders to Swagger to owner:EdgeXFoundry1 edgeXSwaggerPublish ( apiFolders: 'openapi/v1 openapi/v2' ) Publish single folder to swagger with a customer owner/organization. edgeXSwaggerPublish ( owner: 'customOwner' , apiFolders: 'openapi/v1' )","title":"Usage"},{"location":"libraries/edgeXUpdateNamedTag/","text":"edgeXUpdateNamedTag Overview Shared library that wraps the resources/update-named-tag.sh script. This script will create a new \"named\" git tag pointing to an existing git tag. This is really useful for creating \"stable\" or \"experimental\" tags that point to another specific versioned git tag. For example, if you wanted to have a \"stable\" tag point to a version tag of \"v1.4.0\" you can run this script to do so. See usage below. Parameters Name Required Type Description and Default Value ogVersion true str Original version to create named tag from. namedVersion true str Space delimited list of folders to publish. Usage Create a stable tag pointing to a specific version. edgeXUpdateNamedTag ( 'v1.2.3' , 'stable' ) Create an experimental tag pointing to a specific version. edgeXUpdateNamedTag ( 'v2.1.20' , 'experimental' )","title":"edgeXUpdateNamedTag"},{"location":"libraries/edgeXUpdateNamedTag/#edgexupdatenamedtag","text":"","title":"edgeXUpdateNamedTag"},{"location":"libraries/edgeXUpdateNamedTag/#overview","text":"Shared library that wraps the resources/update-named-tag.sh script. This script will create a new \"named\" git tag pointing to an existing git tag. This is really useful for creating \"stable\" or \"experimental\" tags that point to another specific versioned git tag. For example, if you wanted to have a \"stable\" tag point to a version tag of \"v1.4.0\" you can run this script to do so. See usage below.","title":"Overview"},{"location":"libraries/edgeXUpdateNamedTag/#parameters","text":"Name Required Type Description and Default Value ogVersion true str Original version to create named tag from. namedVersion true str Space delimited list of folders to publish.","title":"Parameters"},{"location":"libraries/edgeXUpdateNamedTag/#usage","text":"Create a stable tag pointing to a specific version. edgeXUpdateNamedTag ( 'v1.2.3' , 'stable' ) Create an experimental tag pointing to a specific version. edgeXUpdateNamedTag ( 'v2.1.20' , 'experimental' )","title":"Usage"},{"location":"libraries/edgex/","text":"edgex Overview Shared library of common helper functions for all EdgeX Jenkins pipelines. Functions edgex.isReleaseStream : Used to validate whether the current branch that Jenkins is building is a branch that is considered a branch with \"releasable\" artifacts (i.e docker push, git semver push). edgex.isLTS : Used to determine if the current branch that Jenkins is building is for an LTS release. edgex.getTargetBranch : Used to determine the target branch that is being merged into for a PR. edgex.didChange : Determine if the given expression matches the files that changed in a given PR or merge. For example: // Did any .go files change from the current branch compared to origin/main didChange ( '*.go' ) // Did any .yaml files change from the current branch compared to origin/release didChange ( '*.yaml' , 'origin/release' ) edgex.mainNode : Given a config map with config.nodes , either return the node label marked as defaultNode = true or return the DevOps managed \"default\" node label. edgex.nodeExists : Verify a given node architecture matches provided architecture. edgex.getNode : Return node with architecture that matches provided architecture. edgex.setupNodes : Setup default node labels for x86_64 and arm64 nodes. edgex.getVmArch : Run uname to determine VM architecture. If aarch64 is returned, convert to the result to arm64 . edgex.bannerMessage : Vanity function to wrap given input message with a banner style output for easier readability in Jenkins console. edgex.printMap : Vanity function to print Groovy Map to the Jenkins console. edgex.defaultTrue : Returns true if the input is true or null . This is useful to setup default values in functions when none is provided. edgex.defaultFalse : Returns true if the input is false or null . This is useful to setup default values in functions when none is provided. edgex.releaseInfo : Call shell script resources/releaseinfo.sh to output current edgex-global-pipeline version information in the Jenkins console. This is really useful for debugging older builds in case issues are discovered. edgex.isDryRun : Whether or not the env.DRY_RUN environment variable is set. Will return true if DRY_RUN is set, false otherwise. edgex.isMergeCommit : Determines if the current commit Jenkins is building is considered a git \"merge commit\". Useful if determining parent commit info. edgex.getPreviousCommit : Determines the previous commit SHA given the merge commit or squash commit git use-cases. Different git commands have to be run to be able to determine the previous commit. edgex.getBranchName : Returns the current branch name from git. edgex.getCommitMessage : Returns the current commit message from git given a commit SHA. edgex.isBuildCommit : Return true when the commit message follows the pattern build(...): [semanticVersion,namedTag] ... . edgex.parseBuildCommit : Return the parameters for the build [semanticVersion,namedTag] . edgex.getTmpDir : Run mktemp with given pattern to create a temporary directory in /tmp . edgex.getGoLangBaseImage : Return DevOps managed base images used in Go pipelines. edgex.isGoProject : Looks at repository directory structure to determine if the repository is Golang based. Uses the existence of the go.mod file. edgex.getCBaseImage : Return the base image used as the base image for all C based repositories. edgex.parallelJobCost : Wraps call to lfParallelCostCapture inside docker image to save time downloading pip dependencies. edgex.patchAlpineSeccompArm64 : A fix for arm64 nodes that enables a security profile for docker. Another workaround is to just use the --privileged docker flag. edgex.isLTSReleaseBuild : Returns true if current commit message begins with ci(lts-release) . edgex.semverPrep : Poorly named function that sets up the env.NAMED_TAG and env.BUILD_STABLE_DOCKER_IMAGE for the build commit concept. Will be removed in a future release. edgex.waitFor : Useful function to wait for a condition in a shell script to be met. edgex.waitForImages : Useful function to determine if a docker image has been pushed to a repository.","title":"edgex"},{"location":"libraries/edgex/#edgex","text":"","title":"edgex"},{"location":"libraries/edgex/#overview","text":"Shared library of common helper functions for all EdgeX Jenkins pipelines.","title":"Overview"},{"location":"libraries/edgex/#functions","text":"edgex.isReleaseStream : Used to validate whether the current branch that Jenkins is building is a branch that is considered a branch with \"releasable\" artifacts (i.e docker push, git semver push). edgex.isLTS : Used to determine if the current branch that Jenkins is building is for an LTS release. edgex.getTargetBranch : Used to determine the target branch that is being merged into for a PR. edgex.didChange : Determine if the given expression matches the files that changed in a given PR or merge. For example: // Did any .go files change from the current branch compared to origin/main didChange ( '*.go' ) // Did any .yaml files change from the current branch compared to origin/release didChange ( '*.yaml' , 'origin/release' ) edgex.mainNode : Given a config map with config.nodes , either return the node label marked as defaultNode = true or return the DevOps managed \"default\" node label. edgex.nodeExists : Verify a given node architecture matches provided architecture. edgex.getNode : Return node with architecture that matches provided architecture. edgex.setupNodes : Setup default node labels for x86_64 and arm64 nodes. edgex.getVmArch : Run uname to determine VM architecture. If aarch64 is returned, convert to the result to arm64 . edgex.bannerMessage : Vanity function to wrap given input message with a banner style output for easier readability in Jenkins console. edgex.printMap : Vanity function to print Groovy Map to the Jenkins console. edgex.defaultTrue : Returns true if the input is true or null . This is useful to setup default values in functions when none is provided. edgex.defaultFalse : Returns true if the input is false or null . This is useful to setup default values in functions when none is provided. edgex.releaseInfo : Call shell script resources/releaseinfo.sh to output current edgex-global-pipeline version information in the Jenkins console. This is really useful for debugging older builds in case issues are discovered. edgex.isDryRun : Whether or not the env.DRY_RUN environment variable is set. Will return true if DRY_RUN is set, false otherwise. edgex.isMergeCommit : Determines if the current commit Jenkins is building is considered a git \"merge commit\". Useful if determining parent commit info. edgex.getPreviousCommit : Determines the previous commit SHA given the merge commit or squash commit git use-cases. Different git commands have to be run to be able to determine the previous commit. edgex.getBranchName : Returns the current branch name from git. edgex.getCommitMessage : Returns the current commit message from git given a commit SHA. edgex.isBuildCommit : Return true when the commit message follows the pattern build(...): [semanticVersion,namedTag] ... . edgex.parseBuildCommit : Return the parameters for the build [semanticVersion,namedTag] . edgex.getTmpDir : Run mktemp with given pattern to create a temporary directory in /tmp . edgex.getGoLangBaseImage : Return DevOps managed base images used in Go pipelines. edgex.isGoProject : Looks at repository directory structure to determine if the repository is Golang based. Uses the existence of the go.mod file. edgex.getCBaseImage : Return the base image used as the base image for all C based repositories. edgex.parallelJobCost : Wraps call to lfParallelCostCapture inside docker image to save time downloading pip dependencies. edgex.patchAlpineSeccompArm64 : A fix for arm64 nodes that enables a security profile for docker. Another workaround is to just use the --privileged docker flag. edgex.isLTSReleaseBuild : Returns true if current commit message begins with ci(lts-release) . edgex.semverPrep : Poorly named function that sets up the env.NAMED_TAG and env.BUILD_STABLE_DOCKER_IMAGE for the build commit concept. Will be removed in a future release. edgex.waitFor : Useful function to wait for a condition in a shell script to be met. edgex.waitForImages : Useful function to determine if a docker image has been pushed to a repository.","title":"Functions"},{"location":"releases/jakarta-lts-initial/","text":"Jakarta LTS Changes cd-management New release branch in cd-management to manage lts. Maybe call it lts New field in YAML signifying that this is an LTS release: --- name : 'edgex-go' version : '2.1.0' releaseName : 'jakarta' releaseStream : 'main' lts : true # <-- new field ... Questions? Should we name the lts branch for all repos lts ? OR use it's codename like jakarta ? This would trigger a new process in edgex-global-pipelines@edgeXRelease. See changes to edgex-global-pipelines ci-build-images Branch the golang-1.16 branch to golang-1.16-lts or similar and push the resulting image to the Nexus release repo. Branch the gcc branch to gcc-lts or similar and push the resulting image to the Nexus release repo. These images should be pretty simple as to push to Nexus release because edgeXBuildDocker allows us to specify the Nexus release repository as a target. See dockerNexusRepo in the docs . edgex-compose 3rd party docker images should be archive to the Nexus release repository. Images that should be archived are: consul kong lfedge/ekuiper postgres redis vault A modification to the Jenkinsfile can be make to introduce a new pipeline parameter to trigger a stage that gathers the existing 3rd party images, retags and pushes them to the Nexus release repository. Sample script to extract and retag: for image in $( grep \"image:\" ./docker-compose.yml | grep -v nexus | awk '{print $2}' | sort ) ; do echo docker tag $image nexus3.edgexfoundry.org:10002/3rdparty/ $image ; echo docker push nexus3.edgexfoundry.org:10002/3rdparty/ $image ; done edgex-global-pipelines@edgeXRelease Various changes will be needed in vars/edgexRelease.groovy to support the lts release. See https://github.com/edgexfoundry/edgex-global-pipelines/blob/main/vars/edgeXRelease.groovy#L38 . If we are doing an LTS release we should not create a tag, we need to create a long running branch where changes can be made without affecting the main branch. Changes For Go Repositories As called out in the LTS release process , for Go based projects, we will switch to Go vendoring for dependencies. This will give us 100% confidence that the dependencies will always be available in the LTS release and allow for easy patching and rebuilding. If the release is an LTS release and the LTS branch does not exist , we will need to run something similar to the following: git checkout -b <lts-release-name> grep -v vendor .gitignore > .gitignore.tmp mv .gitignore.tmp .gitignore make vendor git add . git commit -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> If the release is an LTS release and the LTS branch does exist , we will need to run something similar to the following: git checkout <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> Changes For C Repositories There is no dependency management for C based projects, so no dependency management changes are needed. We will need to branch and push though. If the release is an LTS release and the LTS branch does not exist , we will need to run something similar to the following: git checkout -b <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> If the release is an LTS release and the LTS branch does exist , we will need to run something similar to the following: git checkout <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> edgex-global-pipelines General Changes Semver notes and noop builds Git semver will continue to be used for lts releases. After the initial release a pre-release dev tag will be created as usual. However, we have to introduce the concept of a noop (no operation) build due to the fact we are branching and tagging. We can use the commit message as a way to determine a noop build. The flow will go something like this: 1st build, triggered by push of lts branch to GitHub: No op, no semver needed edgeXRelease creates force creates tag 2.1.0 2nd build, triggered by edgeXRelease and builds the 2.1.0 code and pushes the release to Nexus Bump semver to 2.1.1-dev.1 vars/edgex.groovy Potentially need to add a new method similar to isReleaseStream() called isLTS() . Add method or modify getGoLangBaseImage() to return the proper released ci-build-image if this is an LTS release vars/edgeXBuildGoApp.groovy For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call edgex function above. vars/edgeXBuildGoParallel.groovy For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call edgex function above. vars/edgeXBuildCApp.groovy This will be the most complicated change. We will need to release/archive the build images created from the Dockerfile.build. These images will need to be pushed to nexus release and then used as the base images for all subsequent LTS builds. This will ensure we have 100% reproducibility of the C repositories. For example we will need to create a device-coap-c specific docker image will all build dependencies archived in the image. A new stage will need to be added to the pipeline to release the docker build images. This stage can either be triggered by a new parameter to the pipeline, or can potentially be triggered by a special commit message. Since we are already doing a special commit message for the initial push, the commit message may be the correct approach. Changes will be required to the prepBaseBuildImage() function, to use repo level build images if we are on an LTS branch.","title":"Jakarta LTS Changes"},{"location":"releases/jakarta-lts-initial/#jakarta-lts-changes","text":"","title":"Jakarta LTS Changes"},{"location":"releases/jakarta-lts-initial/#cd-management","text":"New release branch in cd-management to manage lts. Maybe call it lts New field in YAML signifying that this is an LTS release: --- name : 'edgex-go' version : '2.1.0' releaseName : 'jakarta' releaseStream : 'main' lts : true # <-- new field ...","title":"cd-management"},{"location":"releases/jakarta-lts-initial/#questions","text":"Should we name the lts branch for all repos lts ? OR use it's codename like jakarta ? This would trigger a new process in edgex-global-pipelines@edgeXRelease. See changes to edgex-global-pipelines","title":"Questions?"},{"location":"releases/jakarta-lts-initial/#ci-build-images","text":"Branch the golang-1.16 branch to golang-1.16-lts or similar and push the resulting image to the Nexus release repo. Branch the gcc branch to gcc-lts or similar and push the resulting image to the Nexus release repo. These images should be pretty simple as to push to Nexus release because edgeXBuildDocker allows us to specify the Nexus release repository as a target. See dockerNexusRepo in the docs .","title":"ci-build-images"},{"location":"releases/jakarta-lts-initial/#edgex-compose","text":"3rd party docker images should be archive to the Nexus release repository. Images that should be archived are: consul kong lfedge/ekuiper postgres redis vault A modification to the Jenkinsfile can be make to introduce a new pipeline parameter to trigger a stage that gathers the existing 3rd party images, retags and pushes them to the Nexus release repository. Sample script to extract and retag: for image in $( grep \"image:\" ./docker-compose.yml | grep -v nexus | awk '{print $2}' | sort ) ; do echo docker tag $image nexus3.edgexfoundry.org:10002/3rdparty/ $image ; echo docker push nexus3.edgexfoundry.org:10002/3rdparty/ $image ; done","title":"edgex-compose"},{"location":"releases/jakarta-lts-initial/#edgex-global-pipelinesedgexrelease","text":"Various changes will be needed in vars/edgexRelease.groovy to support the lts release. See https://github.com/edgexfoundry/edgex-global-pipelines/blob/main/vars/edgeXRelease.groovy#L38 . If we are doing an LTS release we should not create a tag, we need to create a long running branch where changes can be made without affecting the main branch.","title":"edgex-global-pipelines@edgeXRelease"},{"location":"releases/jakarta-lts-initial/#changes-for-go-repositories","text":"As called out in the LTS release process , for Go based projects, we will switch to Go vendoring for dependencies. This will give us 100% confidence that the dependencies will always be available in the LTS release and allow for easy patching and rebuilding. If the release is an LTS release and the LTS branch does not exist , we will need to run something similar to the following: git checkout -b <lts-release-name> grep -v vendor .gitignore > .gitignore.tmp mv .gitignore.tmp .gitignore make vendor git add . git commit -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> If the release is an LTS release and the LTS branch does exist , we will need to run something similar to the following: git checkout <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name>","title":"Changes For Go Repositories"},{"location":"releases/jakarta-lts-initial/#changes-for-c-repositories","text":"There is no dependency management for C based projects, so no dependency management changes are needed. We will need to branch and push though. If the release is an LTS release and the LTS branch does not exist , we will need to run something similar to the following: git checkout -b <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name> If the release is an LTS release and the LTS branch does exist , we will need to run something similar to the following: git checkout <lts-release-name> git commit --allow-empty -m \"ci(lts-release): LTS release v<VERSION> @<commitId from release yaml>\" git push origin <lts-release-name>","title":"Changes For C Repositories"},{"location":"releases/jakarta-lts-initial/#edgex-global-pipelines-general-changes","text":"","title":"edgex-global-pipelines General Changes"},{"location":"releases/jakarta-lts-initial/#semver-notes-and-noop-builds","text":"Git semver will continue to be used for lts releases. After the initial release a pre-release dev tag will be created as usual. However, we have to introduce the concept of a noop (no operation) build due to the fact we are branching and tagging. We can use the commit message as a way to determine a noop build. The flow will go something like this: 1st build, triggered by push of lts branch to GitHub: No op, no semver needed edgeXRelease creates force creates tag 2.1.0 2nd build, triggered by edgeXRelease and builds the 2.1.0 code and pushes the release to Nexus Bump semver to 2.1.1-dev.1 vars/edgex.groovy Potentially need to add a new method similar to isReleaseStream() called isLTS() . Add method or modify getGoLangBaseImage() to return the proper released ci-build-image if this is an LTS release vars/edgeXBuildGoApp.groovy For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call edgex function above. vars/edgeXBuildGoParallel.groovy For LTS releases we need to use the released CI base build image referenced in the ci-build-images section. So we will need to modify this method prepBaseBuildImage() to return the proper base build image if the release is an LTS release. Will call edgex function above. vars/edgeXBuildCApp.groovy This will be the most complicated change. We will need to release/archive the build images created from the Dockerfile.build. These images will need to be pushed to nexus release and then used as the base images for all subsequent LTS builds. This will ensure we have 100% reproducibility of the C repositories. For example we will need to create a device-coap-c specific docker image will all build dependencies archived in the image. A new stage will need to be added to the pipeline to release the docker build images. This stage can either be triggered by a new parameter to the pipeline, or can potentially be triggered by a special commit message. Since we are already doing a special commit message for the initial push, the commit message may be the correct approach. Changes will be required to the prepBaseBuildImage() function, to use repo level build images if we are on an LTS branch.","title":"Semver notes and noop builds"},{"location":"releases/jakarta-release-stages/","text":"Jakarta Release Stages Release Architecture Pre-LTS Flow Post-LTS Flow C Based Services Release Flow \ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha The push of the tag triggers new LTSRelease build Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/19/pipeline/81 \"LTS Release Build\", builds project specific relevant ci build images (x86_64, arm64) will all dependencies bundled Images are pushed to nexus release, i.e. nexus3.edgexfoundry.org:10002/device-coap-c-builder-{ARCH}:{GIT SHA} [Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0 [Existing] edgeXRelease: stages build artifact, i.e. triggers device-coap-c/jakarta job \ud83c\udd95 If this is a C build and LTS we will need to wait until the first LTSRelease build is done before running this build. New function edgex.waitForImages is used to wait until builder images are ready. Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/20/pipeline/154 [Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1 PR Fixes (Regular Dev Process) PR is open in fork as normal, but target branch will be LTS (jakarta) branch [Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-27/7/pipeline/213 \ud83c\udd95 Pipeline will detect the merge target is an LTS branch and will use released ci build image from the release process rather than build a ci image on the fly prepBaseBuildImage() was the perfect abstraction to do this! docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64: { GIT SHA } docker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64: { GIT SHA } ci-base-image-x86_64 docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64: { GIT SHA } docker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64: { GIT SHA } ci-base-image-arm64 Main Branch (Regular Dev Process) PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-29/2/pipeline Go based services Release Flow \ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha The push of the tag triggers new LTSRelease build Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/24/pipeline \"LTS Release Build\" will be a no op build in the case of Golang [Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0 [Existing] edgeXRelease: stages build artifact, i.e. triggers sample-service/jakarta job \ud83c\udd95 No wait needed as of yet, but maybe will need something in the future Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/25/pipeline/147 (need to add lts branches to isReleaseStream) [Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1 PR Fixes (Regular Dev Process) PR is open in fork as normal, but target branch will be LTS (jakarta) branch [Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-135/9/pipeline \ud83c\udd95 getGolangBaseImage will return Go LTS image that DevOps manually releases into Nexus release docker build -t ci-base-image-x86_64 -f Dockerfile --build-arg BASE = nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base:1.16-alpine-lts --build-arg 'MAKE=echo noop' --target = builder . docker build -t ci-base-image-arm64 -f Dockerfile --build-arg BASE = nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base-arm64:1.16-alpine-lts --build-arg MAKE = \"echo noop\" --target = builder . Main branch (Regular Dev Process) PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-136/1/pipeline","title":"Jakarta Release Stages"},{"location":"releases/jakarta-release-stages/#jakarta-release-stages","text":"","title":"Jakarta Release Stages"},{"location":"releases/jakarta-release-stages/#release-architecture","text":"","title":"Release Architecture"},{"location":"releases/jakarta-release-stages/#pre-lts-flow","text":"","title":"Pre-LTS Flow"},{"location":"releases/jakarta-release-stages/#post-lts-flow","text":"","title":"Post-LTS Flow"},{"location":"releases/jakarta-release-stages/#c-based-services","text":"","title":"C Based Services"},{"location":"releases/jakarta-release-stages/#release-flow","text":"\ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha The push of the tag triggers new LTSRelease build Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/19/pipeline/81 \"LTS Release Build\", builds project specific relevant ci build images (x86_64, arm64) will all dependencies bundled Images are pushed to nexus release, i.e. nexus3.edgexfoundry.org:10002/device-coap-c-builder-{ARCH}:{GIT SHA} [Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0 [Existing] edgeXRelease: stages build artifact, i.e. triggers device-coap-c/jakarta job \ud83c\udd95 If this is a C build and LTS we will need to wait until the first LTSRelease build is done before running this build. New function edgex.waitForImages is used to wait until builder images are ready. Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/lts-test/20/pipeline/154 [Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1","title":"Release Flow"},{"location":"releases/jakarta-release-stages/#pr-fixes-regular-dev-process","text":"PR is open in fork as normal, but target branch will be LTS (jakarta) branch [Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-27/7/pipeline/213 \ud83c\udd95 Pipeline will detect the merge target is an LTS branch and will use released ci build image from the release process rather than build a ci image on the fly prepBaseBuildImage() was the perfect abstraction to do this! docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64: { GIT SHA } docker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-x86_64: { GIT SHA } ci-base-image-x86_64 docker pull nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64: { GIT SHA } docker tag nexus3.edgexfoundry.org:10002/device-coap-c-builder-arm64: { GIT SHA } ci-base-image-arm64","title":"PR Fixes (Regular Dev Process)"},{"location":"releases/jakarta-release-stages/#main-branch-regular-dev-process","text":"PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fdevice-coap-c/detail/PR-29/2/pipeline","title":"Main Branch (Regular Dev Process)"},{"location":"releases/jakarta-release-stages/#go-based-services","text":"","title":"Go based services"},{"location":"releases/jakarta-release-stages/#release-flow_1","text":"\ud83c\udd95 edgeXRelease: creates and pushes \"jakarta\" branch at specific git sha The push of the tag triggers new LTSRelease build Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/24/pipeline \"LTS Release Build\" will be a no op build in the case of Golang [Existing] edgeXRelease: tags git sha with release version e.g. 2.1.0 [Existing] edgeXRelease: stages build artifact, i.e. triggers sample-service/jakarta job \ud83c\udd95 No wait needed as of yet, but maybe will need something in the future Job: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/lts-test/25/pipeline/147 (need to add lts branches to isReleaseStream) [Existing] edgeXRelease: Bump Semver, i.e. next dev tag 2.1.1-dev.1","title":"Release Flow"},{"location":"releases/jakarta-release-stages/#pr-fixes-regular-dev-process_1","text":"PR is open in fork as normal, but target branch will be LTS (jakarta) branch [Existing] User open's PR as normal for fix, etc https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-135/9/pipeline \ud83c\udd95 getGolangBaseImage will return Go LTS image that DevOps manually releases into Nexus release docker build -t ci-base-image-x86_64 -f Dockerfile --build-arg BASE = nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base:1.16-alpine-lts --build-arg 'MAKE=echo noop' --target = builder . docker build -t ci-base-image-arm64 -f Dockerfile --build-arg BASE = nexus3.edgexfoundry.org:10002/edgex-devops/edgex-golang-base-arm64:1.16-alpine-lts --build-arg MAKE = \"echo noop\" --target = builder .","title":"PR Fixes (Regular Dev Process)"},{"location":"releases/jakarta-release-stages/#main-branch-regular-dev-process_1","text":"PR open against the main branch, no regressions introduced: https://jenkins.edgexfoundry.org/blue/organizations/jenkins/edgexfoundry%2Fsample-service/detail/PR-136/1/pipeline","title":"Main branch (Regular Dev Process)"},{"location":"tutorials/","text":"Tutorials More coming soon! Manual Version Bump Pull Request Sandbox Testing","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"More coming soon! Manual Version Bump Pull Request Sandbox Testing","title":"Tutorials"},{"location":"tutorials/docker-build-strategy/","text":"Docker Build Strategy Docker is a great tool for the CI/CD ecosystem. As the EdgeX DevOps community, we made the decision early when designing the EdgeX Jenkins pipelines to make Docker the center of our build strategy. The advantage of using Docker as the build context is that it allows for creating reproducible builds from Jenkins to our local build environment. Thus creating a portable build environment and minimizing build errors between environments. The EdgeX Jenkins pipelines use Docker images as the context for any build. This Docker image is generated from the Dockerfile.build found at the root of every EdgeX repository. Any dependencies or packages required for testing or compilation needs to be added to the Dockerfile.build file. Local Testing If we want to test how the build will run on Jenkins we can follow these steps locally. Example First we build the \"build image\" edgex-ci-build-image cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build Now we run the build image with some make targets and bind mount our current directory to a folder called /ws (workspace) docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Or to put it into a convenient one-liner: cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build . && docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Sending build context to Docker daemon 127kB Step 1/8 : ARG BASE=golang:1.15-alpine Step 2/8 : FROM ${BASE} ---> 1a87ceb1ace5 Step 3/8 : LABEL license='SPDX-License-Identifier: Apache-2.0' copyright='Copyright (c) 2019: Intel' ---> Using cache ---> 9f1aa172c1d7 Step 4/8 : RUN sed -e 's/dl-cdn[.]alpinelinux.org/nl.alpinelinux.org/g' -i~ /etc/apk/repositories ---> Using cache ---> fec4da09e9ec Step 5/8 : RUN apk add --no-cache make git gcc libc-dev libsodium-dev zeromq-dev bash ... Successfully built ce2be0b9fe31 Successfully tagged edgex-ci-build-image:latest CGO_ENABLED=1 go test -coverprofile=coverage.out ./... ? github.com/edgexfoundry/app-service-configurable [no test files] CGO_ENABLED=1 go build -ldflags \"-X github.com/edgexfoundry/app-functions-sdk-go/internal.SDKVersion=v1.2.1-dev.35 -X github.com/edgexfoundry/app-functions-sdk-go/internal.ApplicationVersion=0.0.0\" app-service-configurable Tooling Caveats Docker build images are Alpine based to save on disk space and bandwith and with that comes potential tooling incompatiblities. For example a number of pre-installed base packages on Alpine are the BusyBox versions of the tools. BusyBox versions can sometimes have different arguments than their GNU counterparts. For instance the tar command: BusyBox (Alpine) $ tar --help BusyBox v1.31.1 () multi-call binary. Usage: tar c | x | t [ -ZzJjahmvokO ] [ -f TARFILE ] [ -C DIR ] [ -T FILE ] [ -X FILE ] [ --exclude PATTERN ] ... [ FILE ] ... GNU (Other linux distros) $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. This can lead to unexpected issues if say, for instance, you are depending on a specific flag provided by the tool. One option to fix this is to just use the BusyBox flags, however this may break when not running inside the Docker build image. Another option is to find the alternative package and install that version. For example, Alpine provides the GNU alternative tar binary under the tar Alpine package: $ apk add --update tar $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. The Jenkins Way The above example is similar to how Jenkins runs the build with a few distinctions. First, the make test and make build commands are broken up into two stages. This is an important distinction because it allows for a more granular pipeline allowing for better error handling. The other distinction is that Jenkins takes advantage of a caching base layer image that is passed in at build time. Take a look at the Dockerfile.build. You will notice the BASE docker ARG at the top of the file. ARG BASE = golang:1.15-alpine FROM ${BASE} ... This allows Jenkins to override the base image during the build with an image from Nexus helping to alleviate issues with DockerHub pull limits as well as random Docker pull failures. On Jenkins this happens in the Prep stage: docker build -t ci-base-image-x86_64 \\ -f Dockerfile.build \\ --build-arg BASE = nexus3.edgexfoundry.org:10003/edgex-devops/edgex-golang-base:1.15-alpine \\ . The DevOps WG team manages these Golang base images and the Dockerfile for the latest Golang image used can be found here: https://github.com/edgexfoundry/ci-build-images/tree/golang-1.15 . This cache image contains most of the dependencies used in the majority of the pipelines allowing us to cache dependencies at the base image level and increasing builds speeds. After the base image is built the test and build stages run in a similar manner to the local testing scenario: docker run -t -u 0:0 \\ -w /w/workspace/app-service-configurable/60 \\ -v /w/workspace/app-service-configurable/60:/w/workspace/app-service-configurable/60:rw,z \\ -v /w/workspace/app-service-configurable/60@tmp:/w/workspace/app-service-configurable/60@tmp:rw,z \\ ci-base-image-x86_64 ... make test Next steps More information can be found by reading the documentation or source code of these pipelines: edgeXBuildGoApp source edgeXBuildGoParallel source","title":"Docker Build Strategy"},{"location":"tutorials/docker-build-strategy/#docker-build-strategy","text":"Docker is a great tool for the CI/CD ecosystem. As the EdgeX DevOps community, we made the decision early when designing the EdgeX Jenkins pipelines to make Docker the center of our build strategy. The advantage of using Docker as the build context is that it allows for creating reproducible builds from Jenkins to our local build environment. Thus creating a portable build environment and minimizing build errors between environments. The EdgeX Jenkins pipelines use Docker images as the context for any build. This Docker image is generated from the Dockerfile.build found at the root of every EdgeX repository. Any dependencies or packages required for testing or compilation needs to be added to the Dockerfile.build file.","title":"Docker Build Strategy"},{"location":"tutorials/docker-build-strategy/#local-testing","text":"If we want to test how the build will run on Jenkins we can follow these steps locally.","title":"Local Testing"},{"location":"tutorials/docker-build-strategy/#example","text":"First we build the \"build image\" edgex-ci-build-image cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build Now we run the build image with some make targets and bind mount our current directory to a folder called /ws (workspace) docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Or to put it into a convenient one-liner: cd app-service-configurable docker build -t edgex-ci-build-image -f Dockerfile.build . && docker run --rm -v $( pwd ) :/ws -w /ws edgex-ci-build-image sh -c 'make test build' Sending build context to Docker daemon 127kB Step 1/8 : ARG BASE=golang:1.15-alpine Step 2/8 : FROM ${BASE} ---> 1a87ceb1ace5 Step 3/8 : LABEL license='SPDX-License-Identifier: Apache-2.0' copyright='Copyright (c) 2019: Intel' ---> Using cache ---> 9f1aa172c1d7 Step 4/8 : RUN sed -e 's/dl-cdn[.]alpinelinux.org/nl.alpinelinux.org/g' -i~ /etc/apk/repositories ---> Using cache ---> fec4da09e9ec Step 5/8 : RUN apk add --no-cache make git gcc libc-dev libsodium-dev zeromq-dev bash ... Successfully built ce2be0b9fe31 Successfully tagged edgex-ci-build-image:latest CGO_ENABLED=1 go test -coverprofile=coverage.out ./... ? github.com/edgexfoundry/app-service-configurable [no test files] CGO_ENABLED=1 go build -ldflags \"-X github.com/edgexfoundry/app-functions-sdk-go/internal.SDKVersion=v1.2.1-dev.35 -X github.com/edgexfoundry/app-functions-sdk-go/internal.ApplicationVersion=0.0.0\" app-service-configurable","title":"Example"},{"location":"tutorials/docker-build-strategy/#tooling-caveats","text":"Docker build images are Alpine based to save on disk space and bandwith and with that comes potential tooling incompatiblities. For example a number of pre-installed base packages on Alpine are the BusyBox versions of the tools. BusyBox versions can sometimes have different arguments than their GNU counterparts. For instance the tar command:","title":"Tooling Caveats"},{"location":"tutorials/docker-build-strategy/#busybox-alpine","text":"$ tar --help BusyBox v1.31.1 () multi-call binary. Usage: tar c | x | t [ -ZzJjahmvokO ] [ -f TARFILE ] [ -C DIR ] [ -T FILE ] [ -X FILE ] [ --exclude PATTERN ] ... [ FILE ] ...","title":"BusyBox (Alpine)"},{"location":"tutorials/docker-build-strategy/#gnu-other-linux-distros","text":"$ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive. This can lead to unexpected issues if say, for instance, you are depending on a specific flag provided by the tool. One option to fix this is to just use the BusyBox flags, however this may break when not running inside the Docker build image. Another option is to find the alternative package and install that version. For example, Alpine provides the GNU alternative tar binary under the tar Alpine package: $ apk add --update tar $ tar --help Usage: tar [ OPTION... ] [ FILE ] ... GNU 'tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive.","title":"GNU (Other linux distros)"},{"location":"tutorials/docker-build-strategy/#the-jenkins-way","text":"The above example is similar to how Jenkins runs the build with a few distinctions. First, the make test and make build commands are broken up into two stages. This is an important distinction because it allows for a more granular pipeline allowing for better error handling. The other distinction is that Jenkins takes advantage of a caching base layer image that is passed in at build time. Take a look at the Dockerfile.build. You will notice the BASE docker ARG at the top of the file. ARG BASE = golang:1.15-alpine FROM ${BASE} ... This allows Jenkins to override the base image during the build with an image from Nexus helping to alleviate issues with DockerHub pull limits as well as random Docker pull failures. On Jenkins this happens in the Prep stage: docker build -t ci-base-image-x86_64 \\ -f Dockerfile.build \\ --build-arg BASE = nexus3.edgexfoundry.org:10003/edgex-devops/edgex-golang-base:1.15-alpine \\ . The DevOps WG team manages these Golang base images and the Dockerfile for the latest Golang image used can be found here: https://github.com/edgexfoundry/ci-build-images/tree/golang-1.15 . This cache image contains most of the dependencies used in the majority of the pipelines allowing us to cache dependencies at the base image level and increasing builds speeds. After the base image is built the test and build stages run in a similar manner to the local testing scenario: docker run -t -u 0:0 \\ -w /w/workspace/app-service-configurable/60 \\ -v /w/workspace/app-service-configurable/60:/w/workspace/app-service-configurable/60:rw,z \\ -v /w/workspace/app-service-configurable/60@tmp:/w/workspace/app-service-configurable/60@tmp:rw,z \\ ci-base-image-x86_64 ... make test","title":"The Jenkins Way"},{"location":"tutorials/docker-build-strategy/#next-steps","text":"More information can be found by reading the documentation or source code of these pipelines: edgeXBuildGoApp source edgeXBuildGoParallel source","title":"Next steps"},{"location":"tutorials/manual-bump/","text":"Manual Version Bump Process Sometimes the version of the edgex-global-pipelines needs to be changed between stable and experimental tags in order to enhance and validate that the changes work as expected. The process documented here outlines the manual process for bumping the version and tag on the global libraries. Committer Access Required You must have write access to the repo to perform this manual version bump process. - Developer must be a member of the devops-core-team as per TSC approval - Version info can be obtained through view of the Jenkins Pipeline log for last successful build $ git clone git@github.com:edgexfoundry/edgex-global-pipelines.git $ cd edgex-global-pipelines $ ./resources/update-named-tag.sh <version> <stable | experimental> Click on image below to view ASCII recording of the manual version bump process","title":"Manual Version Bump Process"},{"location":"tutorials/manual-bump/#manual-version-bump-process","text":"Sometimes the version of the edgex-global-pipelines needs to be changed between stable and experimental tags in order to enhance and validate that the changes work as expected. The process documented here outlines the manual process for bumping the version and tag on the global libraries.","title":"Manual Version Bump Process"},{"location":"tutorials/manual-bump/#committer-access-required","text":"You must have write access to the repo to perform this manual version bump process. - Developer must be a member of the devops-core-team as per TSC approval - Version info can be obtained through view of the Jenkins Pipeline log for last successful build $ git clone git@github.com:edgexfoundry/edgex-global-pipelines.git $ cd edgex-global-pipelines $ ./resources/update-named-tag.sh <version> <stable | experimental>","title":"Committer Access Required"},{"location":"tutorials/manual-bump/#click-on-image-below-to-view-ascii-recording-of-the-manual-version-bump-process","text":"","title":"Click on image below to view ASCII recording of the manual version bump process"},{"location":"tutorials/pr-commit-for-testing/","text":"Pull Request Sandbox Testing Introduction The EdgeX Jenkins Production Server and EdgeX Jenkins Sandbox Server are configured to use the edgex-global-pipelines library. The servers target either stable or experimental tags for Production and Sandbox servers respectively. To make functional testing of Jenkins Shared Pipeline Libraries more convenient, you can use a commit hash from a Pull Request into edgex-global-pipelines to override the default pipeline version that the Jenkins server is using. ( stable / experimental ) Step 1 - Create Draft PR When you have changes you'd like to functionally test, open a Draft Pull Request from your forked repository of edgex-global-pipelines into edgex-global-pipelines:main Make clear that this is a PR for functional testing purposes and is not meant to be merged. Step 2 - Use PR Commit Hash Find the commit hash of your draft PR. Place the commit hash into your Jenkinsfile that is under test. The EdgeX Sample-Service is a good place to functionally test shared libraries without affecting production code. Add the commit hash after the '@' in the explicit library import statement as shown below. @Library ( \"edgex-global-pipelines@7eba319\" ) _ edgeXBuildGoApp ( project: 'sample-service' , goVersion: '1.15' , buildExperimentalDockerImage: true ) Step 3 - Execute Jenkinsfile When you execute your functional test build job on the sandbox, the commit hash of your PR will be shown as the commit used for the edgex-global-pipeline shared library. You will see a message similar to the following in your build job console output. ... Loading library edgex-global-pipelines@7eba319 Attempting to resolve 7eba319 from remote references... ... Step 4 - Finishing Up When you are satisfied that the content of your edgex-global-pipelines fork is functionally tested and ready to be merged, you can convert your draft PR into a real PR and add the appropriate reviewers. After your PR is merged to main, the experimental tag will point to your newest content. You might want to test your new code by switching back to the experimental tag in your Jenkinsfile. @Library ( \"edgex-global-pipelines@experimental\" ) _ Please clean up and close your PR after you have finished your functional testing.","title":"Pull Request Sandbox Testing"},{"location":"tutorials/pr-commit-for-testing/#pull-request-sandbox-testing","text":"","title":"Pull Request Sandbox Testing"},{"location":"tutorials/pr-commit-for-testing/#introduction","text":"The EdgeX Jenkins Production Server and EdgeX Jenkins Sandbox Server are configured to use the edgex-global-pipelines library. The servers target either stable or experimental tags for Production and Sandbox servers respectively. To make functional testing of Jenkins Shared Pipeline Libraries more convenient, you can use a commit hash from a Pull Request into edgex-global-pipelines to override the default pipeline version that the Jenkins server is using. ( stable / experimental )","title":"Introduction"},{"location":"tutorials/pr-commit-for-testing/#step-1-create-draft-pr","text":"When you have changes you'd like to functionally test, open a Draft Pull Request from your forked repository of edgex-global-pipelines into edgex-global-pipelines:main Make clear that this is a PR for functional testing purposes and is not meant to be merged.","title":"Step 1 - Create Draft PR"},{"location":"tutorials/pr-commit-for-testing/#step-2-use-pr-commit-hash","text":"Find the commit hash of your draft PR. Place the commit hash into your Jenkinsfile that is under test. The EdgeX Sample-Service is a good place to functionally test shared libraries without affecting production code. Add the commit hash after the '@' in the explicit library import statement as shown below. @Library ( \"edgex-global-pipelines@7eba319\" ) _ edgeXBuildGoApp ( project: 'sample-service' , goVersion: '1.15' , buildExperimentalDockerImage: true )","title":"Step 2 - Use PR Commit Hash"},{"location":"tutorials/pr-commit-for-testing/#step-3-execute-jenkinsfile","text":"When you execute your functional test build job on the sandbox, the commit hash of your PR will be shown as the commit used for the edgex-global-pipeline shared library. You will see a message similar to the following in your build job console output. ... Loading library edgex-global-pipelines@7eba319 Attempting to resolve 7eba319 from remote references... ...","title":"Step 3 - Execute Jenkinsfile"},{"location":"tutorials/pr-commit-for-testing/#step-4-finishing-up","text":"When you are satisfied that the content of your edgex-global-pipelines fork is functionally tested and ready to be merged, you can convert your draft PR into a real PR and add the appropriate reviewers. After your PR is merged to main, the experimental tag will point to your newest content. You might want to test your new code by switching back to the experimental tag in your Jenkinsfile. @Library ( \"edgex-global-pipelines@experimental\" ) _ Please clean up and close your PR after you have finished your functional testing.","title":"Step 4 - Finishing Up"},{"location":"tutorials/unit-testing-best-practices/","text":"Unit Testing Best Practices Table Of Contents Unit Testing Declarative Pipelines Encapsulate Pipeline logic within Groovy functions Example Mocking Jenkins Dependencies Add plugin dependency to Gradle Mocking Environment Variables Testing environment variables Mock external shared library methods Integration Testing Mock errors Mock external shared library methods Call Graph Example References Unit Testing Declarative Pipelines The edgex-global-pipelines shared library leverages the Jenkins Spock framework for unit testing Jenkins pipeline scripts and functions. The Jenkins Spock unit test framework does not currently support unit testing of Jenkins Declarative Pipeline code . Encapsulate Pipeline logic within Groovy functions In order to facilitate unit testing of the edgex-global-pipelines shared library, the DevOps team has made a deliberate effort to to minimize the amount of scripting logic contained within Jenkins declarative pipelines. This is accomplished by encapsulating pipeline logic within a Groovy function and calling the function in the declarative pipeline step as needed. Localizing pipeline logic within Groovy functions enables the Jenkins Spock framework to provide greater test coverage of Pipeline logic. Example An example this approach can be seen within the Build -> amd64 -> Prep stage of the edgeXBuildCApp Delcarative Pipeline . Note the logic for prepping the base build image is encapsulated into a method named prepBaseBuildImage and it is called within the declarative Pipeline. Also the prepBaseBuildImage function logic is thoroughly unit tested in the edgeXBuildCApp Spec Mocking Jenkins Dependencies Always leverage the builtin capabilities of the Jenkins-Spock framework for mocking Jenkins plugins. For example, if you come across the following error when unit testing your code: java.lang.IllegalStateException: During a test, the pipeline step [stepName] was called but there was no mock for it. The error above denotes that the code under test calls a pipeline step stepName but there is no mock for it. You are able to explicitly mock the pipeline step using explictlyMockPipelineStep method available in the Jenkins-Spock framework. However it is recommended that the plugin that contains the corresponding step be added as a dependency in the build.gradle file. For instructions on how to do this, refer to the Add plugin dependency to Gradle section. Add plugin dependency to Gradle Note the name of the Pipeline Step to add. Go to Pipeline Steps Reference page. Use your browser and search for the Pipeline Step within the page. If the Pipeline Step is found, click on the Pipeline that it belongs to, the page for the respective Pipeline should open. Under the heading click on the View this plugin on the Plugins site link, the plugins.jenkins.io page should open. In the plugins.jenkins.io page note the ID for the Pipeline. You will use this ID in the next step. Go to Maven Repository page. Enter the ID in the search, and locate the result from the results displayed, click on the respective link. In the page, click on the Jenkins Releases tab. If you know the version then click it, otherwise click on the latest version that is listed. In the Gradle tab, note the group, name and version. Edit the build.gradle file, add the dependency found above to the dependencies section. Mocking Environment Variables Always ensure the source code under test uses one of the following idioms for getting or setting Environment Variables, doing this will simplify the ability to mock environment variables in the unit test: - Getting the value of an environment variable - env.VARIABLE - env[VARIABLE] - \"${env.VARIABLE}\" - Setting the value of an environment variable - env.VARIABLE = VALUE - env[VARIABLE] = VALUE Testing environment variables Within your unit tests, environment variables are set using the .getBinding().setVariable('name', 'value') idiom. Where the name is env and the value is a map you define within your unit test. The map should define all environment variables the code under test expects, likewise the map can be used to assert any environment variables that the code under test sets. A good example of this practice is the EdgeXSetupEnvironmentSpec Mock external shared library methods The edgex-global-pipelines Jenkins shared library consists of multiple scripts exposing methods for various functional areas, where each script is named after the particular functional area it serves. The shared library includes a EdgeX script that serves as utility script containing methods that are shared amongst other scripts. It is common practice for a method in one script call a method in another script, to mock the interaction you use the explictlyMockPipelineVariable to mock the script, then getPipelineMock method to verify the interaction or stub it if necessary. Mock the external script named script : explictlyMockPipelineVariable('script') It is recommended to mock all external scripts called within the script under test in the Test Spec setup. Get the script mock and stub the call to method to return 'value' for any argument passed in: getPipelineMock('script.method').call(_) >> 'value' Integration Testing Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group. The Jenkins-Spock framework provides the ability to load any number of scripts to test within a given Spec Test. There are instances where performing integration tests is more practical, if you wish to do so then we recommend naming the Spec Test with Int as to differentiate between unit and integration tests. A good example of this practice is the EdgeXReleaseDockerImageIntSpec Mock errors Always leverage error when wanting to conditionally abort part of your script. Error is a Pipeline Step whose plugin has been added as a dependency to our project thus is already mocked by the framework. An example showing how you can assert that an error is thrown with a specific message: 1 * getPipelineMock('error').call('error message') Mock external shared library methods The difficulties of mocking functions within the same script under test have been described in the following issue: Issue 78 . Due to the nature of how the scripts that comprise the edgex-global-pipelines shared library are written; where a deliberate intent is made to develop small, functionally cohesive methods that contribute to a single well-defined task. This development intent results in having scripts with multi-layered call graphs, where methods may call multiple methods from within the same script. We find that the workaround provided in the issue is complicated and doesn't scale well in our environment. For these reasons the method outlined below is being suggested. For the script under test, document its call graph. A call graph is a control flow graph, which represents calling relationships between methods in a script or program. Each node represents a method and each edge (f, g) indicates that method f calls method g. An example EdgeXReleaseGitTag call graph is depicted below. Create a second script with the same name as the original script with the word Util added to the end, for example EdgeXReleaseGitTagUtil.groovy . Analyze the call graph, methods that reside in odd numbered layers should continue to reside in the first script, methods at even numbered layers should be moved from the first script into the second script. Create a Spec Test for both scripts. Mocking of methods between both scripts follow the same pattern described for Mock external shared library methods . The only difference with this approach is that the scripts are (for the lack of a better word) name spaced for the respective functional area. Call Graph Example NOTE The approach outlined above is not recommended as the standard development approach, but as an alternative to re-writing the script under test if mocking of the internal method calls becomes unwieldy. References Jenkins Spock Documentation Spock Framework Reference Jenkins Shared Libraries","title":"Unit Testing Best Practices"},{"location":"tutorials/unit-testing-best-practices/#unit-testing-best-practices","text":"","title":"Unit Testing Best Practices"},{"location":"tutorials/unit-testing-best-practices/#table-of-contents","text":"Unit Testing Declarative Pipelines Encapsulate Pipeline logic within Groovy functions Example Mocking Jenkins Dependencies Add plugin dependency to Gradle Mocking Environment Variables Testing environment variables Mock external shared library methods Integration Testing Mock errors Mock external shared library methods Call Graph Example References","title":"Table Of Contents"},{"location":"tutorials/unit-testing-best-practices/#unit-testing-declarative-pipelines","text":"The edgex-global-pipelines shared library leverages the Jenkins Spock framework for unit testing Jenkins pipeline scripts and functions. The Jenkins Spock unit test framework does not currently support unit testing of Jenkins Declarative Pipeline code .","title":"Unit Testing Declarative Pipelines"},{"location":"tutorials/unit-testing-best-practices/#encapsulate-pipeline-logic-within-groovy-functions","text":"In order to facilitate unit testing of the edgex-global-pipelines shared library, the DevOps team has made a deliberate effort to to minimize the amount of scripting logic contained within Jenkins declarative pipelines. This is accomplished by encapsulating pipeline logic within a Groovy function and calling the function in the declarative pipeline step as needed. Localizing pipeline logic within Groovy functions enables the Jenkins Spock framework to provide greater test coverage of Pipeline logic.","title":"Encapsulate Pipeline logic within Groovy functions"},{"location":"tutorials/unit-testing-best-practices/#example","text":"An example this approach can be seen within the Build -> amd64 -> Prep stage of the edgeXBuildCApp Delcarative Pipeline . Note the logic for prepping the base build image is encapsulated into a method named prepBaseBuildImage and it is called within the declarative Pipeline. Also the prepBaseBuildImage function logic is thoroughly unit tested in the edgeXBuildCApp Spec","title":"Example"},{"location":"tutorials/unit-testing-best-practices/#mocking-jenkins-dependencies","text":"Always leverage the builtin capabilities of the Jenkins-Spock framework for mocking Jenkins plugins. For example, if you come across the following error when unit testing your code: java.lang.IllegalStateException: During a test, the pipeline step [stepName] was called but there was no mock for it. The error above denotes that the code under test calls a pipeline step stepName but there is no mock for it. You are able to explicitly mock the pipeline step using explictlyMockPipelineStep method available in the Jenkins-Spock framework. However it is recommended that the plugin that contains the corresponding step be added as a dependency in the build.gradle file. For instructions on how to do this, refer to the Add plugin dependency to Gradle section.","title":"Mocking Jenkins Dependencies"},{"location":"tutorials/unit-testing-best-practices/#add-plugin-dependency-to-gradle","text":"Note the name of the Pipeline Step to add. Go to Pipeline Steps Reference page. Use your browser and search for the Pipeline Step within the page. If the Pipeline Step is found, click on the Pipeline that it belongs to, the page for the respective Pipeline should open. Under the heading click on the View this plugin on the Plugins site link, the plugins.jenkins.io page should open. In the plugins.jenkins.io page note the ID for the Pipeline. You will use this ID in the next step. Go to Maven Repository page. Enter the ID in the search, and locate the result from the results displayed, click on the respective link. In the page, click on the Jenkins Releases tab. If you know the version then click it, otherwise click on the latest version that is listed. In the Gradle tab, note the group, name and version. Edit the build.gradle file, add the dependency found above to the dependencies section.","title":"Add plugin dependency to Gradle"},{"location":"tutorials/unit-testing-best-practices/#mocking-environment-variables","text":"Always ensure the source code under test uses one of the following idioms for getting or setting Environment Variables, doing this will simplify the ability to mock environment variables in the unit test: - Getting the value of an environment variable - env.VARIABLE - env[VARIABLE] - \"${env.VARIABLE}\" - Setting the value of an environment variable - env.VARIABLE = VALUE - env[VARIABLE] = VALUE","title":"Mocking Environment Variables"},{"location":"tutorials/unit-testing-best-practices/#testing-environment-variables","text":"Within your unit tests, environment variables are set using the .getBinding().setVariable('name', 'value') idiom. Where the name is env and the value is a map you define within your unit test. The map should define all environment variables the code under test expects, likewise the map can be used to assert any environment variables that the code under test sets. A good example of this practice is the EdgeXSetupEnvironmentSpec","title":"Testing environment variables"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods","text":"The edgex-global-pipelines Jenkins shared library consists of multiple scripts exposing methods for various functional areas, where each script is named after the particular functional area it serves. The shared library includes a EdgeX script that serves as utility script containing methods that are shared amongst other scripts. It is common practice for a method in one script call a method in another script, to mock the interaction you use the explictlyMockPipelineVariable to mock the script, then getPipelineMock method to verify the interaction or stub it if necessary. Mock the external script named script : explictlyMockPipelineVariable('script') It is recommended to mock all external scripts called within the script under test in the Test Spec setup. Get the script mock and stub the call to method to return 'value' for any argument passed in: getPipelineMock('script.method').call(_) >> 'value'","title":"Mock external shared library methods"},{"location":"tutorials/unit-testing-best-practices/#integration-testing","text":"Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group. The Jenkins-Spock framework provides the ability to load any number of scripts to test within a given Spec Test. There are instances where performing integration tests is more practical, if you wish to do so then we recommend naming the Spec Test with Int as to differentiate between unit and integration tests. A good example of this practice is the EdgeXReleaseDockerImageIntSpec","title":"Integration Testing"},{"location":"tutorials/unit-testing-best-practices/#mock-errors","text":"Always leverage error when wanting to conditionally abort part of your script. Error is a Pipeline Step whose plugin has been added as a dependency to our project thus is already mocked by the framework. An example showing how you can assert that an error is thrown with a specific message: 1 * getPipelineMock('error').call('error message')","title":"Mock errors"},{"location":"tutorials/unit-testing-best-practices/#mock-external-shared-library-methods_1","text":"The difficulties of mocking functions within the same script under test have been described in the following issue: Issue 78 . Due to the nature of how the scripts that comprise the edgex-global-pipelines shared library are written; where a deliberate intent is made to develop small, functionally cohesive methods that contribute to a single well-defined task. This development intent results in having scripts with multi-layered call graphs, where methods may call multiple methods from within the same script. We find that the workaround provided in the issue is complicated and doesn't scale well in our environment. For these reasons the method outlined below is being suggested. For the script under test, document its call graph. A call graph is a control flow graph, which represents calling relationships between methods in a script or program. Each node represents a method and each edge (f, g) indicates that method f calls method g. An example EdgeXReleaseGitTag call graph is depicted below. Create a second script with the same name as the original script with the word Util added to the end, for example EdgeXReleaseGitTagUtil.groovy . Analyze the call graph, methods that reside in odd numbered layers should continue to reside in the first script, methods at even numbered layers should be moved from the first script into the second script. Create a Spec Test for both scripts. Mocking of methods between both scripts follow the same pattern described for Mock external shared library methods . The only difference with this approach is that the scripts are (for the lack of a better word) name spaced for the respective functional area.","title":"Mock external shared library methods"},{"location":"tutorials/unit-testing-best-practices/#call-graph-example","text":"NOTE The approach outlined above is not recommended as the standard development approach, but as an alternative to re-writing the script under test if mocking of the internal method calls becomes unwieldy.","title":"Call Graph Example"},{"location":"tutorials/unit-testing-best-practices/#references","text":"Jenkins Spock Documentation Spock Framework Reference Jenkins Shared Libraries","title":"References"}]}